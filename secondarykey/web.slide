Webサーバ とWebフレームワーク
Shizuoka.go Vol.15
23 Nov 2019
Tags:golang,shizuokago

secondarykey
Programmer
https://github.com/secondarykey/
@secondarykey

* まずは動かして見よう！

* よく見かけるサンプル

.code server.go

.caption server.go

Go言語では標準ライブラリで
簡単にHTTPサーバを実装することが可能です。
※サンプルコードでは適切にエラー処理を行っていません。

* Webの基本

Webシステムはクライアントからリクエストを受け取って
レスポンスでデータを返します。

    fmt.Fprintf(w, "Hello, you've requested: %s\n", r.URL.Path)

Goでは

r = *http.Request
w = http.ResponseWriter

という型で実現して行きます。

このサンプルではクライアントがリクエストしたURLの情報を
Writerに文字列として返していることがわかります。



* http.Request

- r.URL : リクエストされたURLが入っています。(クエリなど)
- r.Method : 呼び出しのメソッドが入ってきます。

などなど、もちろんヘッダ情報なども入っています。
詳しくはRequestを見てください

.link https://golang.org/pkg/net/http/#Request

* http.ResponseWriter

ResponseWriterはinterfaceで定義されています。

    w.Write([]byte)

で書き込むこともできますが、
ResponseWriterはio.Writerになっているので、サンプルのように

    fmt.Fprintf(w,"hoge")

という風に書き込むこともできます。

* ヘッダー情報の書き込み

ResponseWriterはヘッダー情報として

    w.Header().Set("content-type","text/html")

という記述や、ステータス値として、intを設定できます。

    w.WriteHeader(http.StatusOK)

※いわゆる200,404,500などです。
ステータスの数値はhttp上にhttp.StatusXxxxxとして定義してあります。

* Ex(tra) : HTTPSサーバ

HTTPSサーバも簡単に立ち上げられます。
開発環境だけで証明書を作成することも可能です。

  $ go run $GOROOT/src/crypto/tls/generate_cert.go --host localhost

を行って証明書を出力し、

.code ssl.go /^func main/,/^}/

と実行するだけでHTTPSを実現できます。

これにより、容易に開発環境でHTTP 2(SSLが必須)も実現でき、
そのHTTP2前提であるgRPCを実現することも容易です。

* http.HandleFunc()を見てみる

http.HandleFunc()の引数を見ていくと

    func HandleFunc(pattern string, handler func(ResponseWriter, *Request))

と定義してあることがわかります。
Goでは関数を変数として扱うことができ、それがfunc() という型になります。

   http.HandleFunc("/foo",func(w http.ResponseWriter,r *Request){
     //not implemented
   }) 

という風に書いて無名関数として処理することも可能です。

http.HandleFunc()をURLのパターンで複数設定していき、
サーバ実行時に関数を呼び出す仕組みになっています。

* Ex : 標準パッケージのドキュメント

標準パッケージは以下のURLで見ることができます。
※pkg後にパッケージ名

.link https://golang.org/pkg/net/http

ネットワークが存在しなくても、Goが入っているなら

    > go doc net/http HandleFunc

ともできますし、Goはソースコードを持っていますので
$GOROOT/src/net/http の中のコードを見ることで、どのように実装されているかもわかります。

* HTMLを返してみる

多くのWebサーバはHTMLを返すことになると思います。

例えば

.code example.go /^func htmlHandler/,/^}/

.caption example.go htmlHandler

こう書いて上げるとブラウザがHTMLとして認識して表示してくれます。
まぁHTMLは複雑になってくるはずなので、
文字列で書いて行くのは現実的ではありません。

* テンプレートでかく

Goは標準でテンプレートエンジンを持っています。

    html/template

というパッケージがありそれで書くことが多いと思います。

.code example.go /^func templateHandler/,/^}/

.caption example.go templateHandler

これでテンプレートにHTMLを書いていきます。

* テンプレートの中身

.code template.tmpl

Excute()の第２引数である変数を{{ . }} を用いてアクセスしています。

今回はサンプルで文字列を設定していますが、
構造体を設定したり、関数を呼び出したり色々できます。

・・・Goのテンプレートはあんまり好きな人は多くない印象です。

* JSONを返してみる

Go言語は

    encoding/json

というJSONを扱う標準ライブラリで

.code example.go /^func jsonHandler/,/^}/

という感じで構造体をそのままJSONにすることが可能です。

* Ex: 小文字の定義を行う

Go言語では大文字でしか外部パッケージからはアクセスできない為、
※小文字はパッケージ内のprivate扱いになります

.code example.go /^type JSONOutput struct/,/^}/

JSON出力する項目は上の感じに大文字でしか定義できません。
その為JSONでの出力もなってしまう為、
小文字のJSONを出力したい場合は上記のように
`json:"name"`というタグを設定して上げる必要があります。

* Static Server

* 静的なコンテンツを扱う

Webでは動的な処理が必要ない、
JavaScript,CSS,画像データが存在します。

.code example.go /^func registerAssets/,/^}/

http.FileServer()でファイルシステムを設定し、
http.Handle() で登録してあげます。

これにより、/static/* に対して存在するファイルをHTTPで返してくれるようになります。

※http.Handle()の扱いについては後述します。

* Cookie

* いわゆるSession

Webではクライアント固有の情報をCookieで保存しますが、
net/httpにも準備されています。

.code example.go /^func setCookieHandler/,/^}/

という感じでCookieを作成しておきます。

* 別のURLで読み込む

.code example.go /^func cookieHandler/,/^}/

で取得が可能です。

* サーバの起動

* http.ListenAndServe()

サーバの起動時に呼んでいて、処理が止まります。

定義を見てみると

    func ListenAndServe(addr string, handler Handler) error

となっています。
第1引数では、"host:port"としてサーバ名とポートを指定します。
hostは省略しない場合、そのホスト名でしかアクセスできません。

サンプルでよくnil省略される第2引数Handlerは大きな意味があります。

* Ex : Shutdown

ListenAndServe内ではServerと呼ばれるインスタンスが起動してWebリクエストを待ち受けます。

.code shutdown.go /^func main/,/^}/

何個もWebサーバを起動しておいて、何らかの操作でストップすることができます。

* http.Handler

Handlerの実態はinterfaceです。

    type Handler interface {
        ServeHTTP(ResponseWriter, *Request)
    }

となっています。 

Handlerはnilを指定された場合、
DefaultServeMuxというhttp内の変数が使用されて動作します。

DefaultServeMuxはServeMuxという型で、
http.HandleFunc()ではDefaultServeMuxに登録されています。

* http.ServeMux

ServeMuxはいわゆるルーターで、

    http.HandleFunc("/foo",fooHandler)
    http.HandleFunc("/bar",barHandler)

という時にURLに応じて、登録した関数を実行しています。

こういった場合に認証をかけたい、トレースログ出力が行いたいという時
それぞれの関数に埋め込まなくては行けなくなります。

Handlerを定義して、そこにログを出力するような処理を書くことができます。
それぞれの処理に振り分けることができるわけです。

* http.Handle()

Static Serverで行った処理ですが、

    func Handle(pattern string, handler Handler)

FileServerはhttp.Handlerになっていて、
"/static/"へのアクセスはFileServerが呼び出せれて処理されます。

ListenAndServe() 以外で指定されたURLの場合はそちらのHandlerで動作します。

* e.g : ログを取ってみる

実は先程からのサンプルはすべて

    func (h *Logger) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        log.Println(r.URL)
        h.ServeMux.ServeHTTP(w, r)
    }

というHandlerを噛ましてました。

    logger := Logger{http.NewServeMux()}
    logger.HandleFunc("/", indexHandler)
    http.ListenAndServe(":5555", &logger)

DefaultServeMuxと同じ型を挟んでそのServeHTTP()にログを挟んでいるだけです。
※ログを見てみる

* Ex:middleware

Handlerを使うことでも解決しますが、
これには関数をかませる方法などの紹介も多くあります。

    http.HandleFunc("/",Middleware(func()))

この実装方式でも同じように扱うことはできます。
このパターンが優秀なのは様々なミドルウェアをつなげることができます。

認証、ログ、その他をURL毎に変更することが可能で、
こちらの方が柔軟な処理に対応できる可能性があります。

.link https://gowebexamples.com/advanced-middleware/ go.dev

* テスト

* テストの話

hogedigoがテストなので少しだけ触れておきます。

    net/http/httptest

が用意されていて、

    httptest.Server
    httptest.ResponseRecorder

を利用して擬似的にテストを行うことが可能です。

    ts := httptest.NewServer(Handler)

で擬似的にサーバを作成して呼び出して見たり、

    res := httptest.NewRecorder()
    req, err := http.NewRequest(http.MethodGet, URL, nil)

としてRequest,ResponseWriterを作成して、
直接呼び出したりして、テストして行きます。

* Webフレームワーク

* net/httpの基礎

どんなWebフレームワークも前述した基礎がベースになって構築されていると思うので
これをベースに考えれば、難しいことはないと思います。

少し人気のありそうなフレームワークを見ていって
どのような実装になるのか見てみましょう。

* Webフレームワーク一覧

※GitHub APIで検索クエリでトップ４(スター数)を調べてみました。

.link https://bit.ly/348KlnS

- gin (https://github.com/gin-gonic/gin)
- beego (https://github.com/astaxie/beego)
- iris (https://github.com/kataras/iris)
- echo (https://github.com/labstack/echo)

辺りが人気になるのかな？

これらがHTTPサーバを立てるにあたって起こる問題を
どのように解決しているかを見ていきたいと思います。

軽く見た限りですので、間違っていたら言ってください。

* 実行してみる

* Gin

.code gin.go /^func main/,/^}/

トレースがかっこいい！

* Beego

.code beego.go /^func main/,/^}/

知る限り、当初からあるフレームワーク
パッケージメソッドでの呼び出し

* Iris

.code iris.go /^func main/,/^}/

・・・

* echo

.code echo.go /^func main/,/^}/

唯一戻り値にエラーが使えます。

* Router

* URLの判別

Go言語の特徴の一つなんですが、
Goは色々やってくれるけど、便利なことはやらない、、、

   http.HandleFunc("/agree/",agreeHandler)

とURLの登録を行い、

   /agree/hello/secondarykey

とアクセスするとagreeHandlerが反応しますが、
URLに意味がある場合、URLを解析する必要があります。

* どういうことかっていうと、、、

.code example.go /^func agreeHandler/,/^}/

* それぞれのrouter

* Gin

    r.GET("/:name",func(c *gin.Context) {
        name := c.Param("name")
    })

contextの中に変数として入っています。

* Beego

    beego.Get("/:name",func(c *context.Context) {
        name := c.Input.Param(":name")
    }

beegoのRouterにはControllerという考え方があり、
構造体を登録して、そのメソッドを呼び出すとかの強烈な機構がある

* Iris

   app.Get("/{name}", func(ctx iris.Context){
       id := ctx.Params().Get("name")
   })

* echo

    e := echo.New()
    e.GET("/:name", func(c echo.Context) error {
        return c.String(http.StatusOK, "Hello," + c.Param("name"))
    })

* Session

* 単純に保存してしますと、、、

サンプルの実はデータがそのまま見えてしまいます。

- Gin -> secureのフラグはあるが、HTTPSの属性
- Beego -> SetSecureCookie()がある
- Iris -> Option指定はできるけど、準備はされてないっぽい
- echo -> そのまま設定

すべてContextにCookieの設定はできるようですが、暗号化はBeegoのみでした。
まぁテメーでやれってことですね。

* Middleware

* 先程説明したMiddlewareをどのように扱っているか？を見てみます。


- Gin

    app.Use(myMiddleware)

- Beego

   beego.InsertFilter()

パターンや順序を指定して実行しています。

- Iris

    app.Get("/", before, mainHandler, after) 

そのメソッドに設定する感じですね。

- echo

    e.Use(middleware.Logger())

* Template

- Gin -> c.HTML()で引数指定、Go標準
- Beego -> Controller辺りで行うみたい
- Iris -> mvcを利用して指定する感じ？
- echo -> c.Render()で引数指定、Go標準

Go標準のテンプレート以外は使ってない感じですね。

* ざっと見た感想

調べる時間がなくて、駆け足になってしまいましたが、
私は基本的にどれも使ってなくて、
様々な機能が分割されているgorillaを必要な時に使っています。

.link https://www.gorillatoolkit.org/ gorilla

基本的な知識があればだいたい怖くないかな？とは思います。

Ginは洗練された感じ、
Beegoは老舗っぽくフルスッタックで色々機能がありそう。
Irisは、、、、
echoが軽いっぽくて好きかな？

調べる前に思ったより全部似てました。


* 他のフレームワーク

実は端折った５位にいたrevel(フルスタックで最終リリースが2018年だった)や
マイクロサービス用で人気がありそうなのがgoaなどがあります。

.link https://revel.github.io/ revel
.link https://github.com/goadesign/goa goa

* Ex: 最後に

HTTP周りの勉強を行いたいのであれば、
「Real World HTTP」という書籍をおすすめします。

.link https://www.oreilly.co.jp/books/9784873118048/ Real World HTTP

Goの勉強というより、HTTPの勉強なのですが、
Goで書いてあって、非常にHTTPを体系的に学ぶことができる書籍です。

。。。なんか宣伝みたくなったな、、、
