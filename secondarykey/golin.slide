そろそろ自分を信じていい頃です
Shizuoka.go Vol.13
30 Mar 2019
Tags:golang

secondarykey
Programmer
https://github.com/secondarykey/
@secondarykey

* Tourを終えた人へ

.link https://go-tour-jp.appspot.com/welcome/1 A Tour of Go

をやり終えて簡単な言語仕様は把握したところで何作ろうかな？と悩んでいる方に向けた資料になります。

Go は簡単にHTTPサーバを立てたりもできますが、さまざまなプラットフォームでの動作も可能なため、マンドをを作ることにも適しています。

今回はコマンドを作りながらGoでソフトを作る時のTipsやGoのサブコマンドの使い方などでGoの魅力を紹介できたらなぁと思います。


* いろいろできるGo言語

まずはいままで私が作ってきたものを紹介したいと思います。
私の場合は仕事ではなく、仕事上でのツールを作ることが多く、Goはすごく重宝しています。

あまりにもメンテナンスをしていなくて、ほぼ死んでるのでメンテしてかないと。。。と思いながら開いて「わぁ」ってなって閉じていることが多いです。

Goではいろんなことができるのが伝われば幸いです。


* github.com/shizuokago/blog

GAE/Goのブログエンジン

GopherJSでエディタを作成していてちょっと最近触ろうと思ったんだけど、GopherJSどころかjQuery依存していて、移行できるか心配。

GopherJSはGo言語でJavaScriptを動作させる仕組みで、GopherJSでコンパイルするとJavaScriptファイルをジェネレートしてくれます。

開発当初はかなりのキワモノだと思っていましたが、現在もメンテナンスをされており、いろんな場所で活躍しているみたいです。

.link https://github.com/gopherjs/gopherjs GopherJS



* github.com/secondarykey/speaks

Simple SNS

閉ざされたネットワーク上のレガシーな現場でチャットシステムを導入するべく作ったチャットシステム。
Go言語はHTTPだけではなくWebSocketも気軽にサーバを立ち上げることが可能です。

先日、jQueryを排除してMDL化しました。ActiveDirectoryアクセスを可能にしてより簡単に導入できるようにしています。ただ冷静に考えたらWebSocketではなく、gRPC化をしたほうがかっちょええってことに気付いて現在設計中。

.link https://godoc.org/golang.org/x/net/websocket

.link https://github.com/go-ldap/ldap

.link https://github.com/grpc/grpc-go



* github.com/shizuokago/gopredit

GAE/GoでGoのpresentionツールをサービス化してみたものです。
先日動かしてみたら見事に動きませんでした。かなり初期に作ったのでソース見たらボロボロでした。(panicの連発。以前使ってたテストフレームワークも使っていてすごいことになってました。

現在この資料も含めて管理方法を模索中でして、簡単にプレゼンをまとめれたらなぁと思っています。

なおこの発表資料もpresentで作成しています。

.link https://godoc.org/golang.org/x/tools/present


* github.com/secondarykey/dizzy

先程説明のあった静的解析を行ってDatastoreに簡易的にアクセスする為に作成したもの。
ちょうど実装中に少し大きなものを作成開始してしまい、それに適用しなかった為、実運用をのがした悲しいツール

ナイツオ社製の薄いライブラリを利用して行っています。

.link https://github.com/knightso/base/tree/master/gae 

dizzyの内部にあるtestを手元で自動実行するコマンドを持っていて、
それをツール化して抜き出したい。


* github.com/secondarykey/davgo

WebDAVアクセスを行った時に使ったもの。
久しぶりに見たら案外コードが書いてあって、全部自分でコーディングしたのか怪しい。(サンプル持ってきただけ？

.link https://github.com/wtnb75/davgo

某社の某ストレージサービスへのAPI公開時に作ったもの。ﾁﾗﾁﾗ

* github.com/secondarykey/yuru

某パズルゲームの計算アルゴリズムを作成しました。
アルゴリズムの勉強用ではあったのですが、チューニング等の勉強をした記憶もある

本当はGoMobileと連携して、パズルゲームシュミレーターみたいなものにしようと思ってたけど、現在暗礁に乗り上げています。


.link https://github.com/golang/mobile 



* github.com/ikascrew/ikascrew

いわずとしれたVJ イカスクリューを支えるVJ System。

opencvを利用した動画表示、切替を行う仕組みであり、Shinyによる表示などができないか？などを作成してみたりしたこともある。

最近VJをやってないので少し放置気味ですが、go-opencvからgocv.ioに変更を行いました。


.link https://gocv.io/ GoCV

本当は動画データベースを作り込みたい


* github.com/ikascrew/xbox

USBのゲームコントローラーのイベントを拾うライブラリ。

動画操作の為に作成したものではあるが、実はこのコード(ライブラリを使いやすくしただけですが)を書いた後にアメリカ海軍がXBOXのコントローラーを採用しました。
製造業の現場などで使われる可能性も視野に入れていいかもなぁなんて思ってますが今の所提案したことはない。

実はオリジナルでトグルを作成し、ボリュームコントローラーなどを自作しようかな？などと思っています。

現在、コントローラーはスーファミになってます。



* その他

FTPベースでファイルを同期するmysyncというものも存在するのですが、それはとある世界線にしか存在しません。

その仕組みを使っているシステムは、開発環境自体の仕組みが特殊で特有の同期を行います。

後はサイトのスクレイピングを簡易的に行えるようなコマンドを持っているのですが、いい感じでUIが作れないので手元にあるだけになっているコードとかもあります。

* Let's Go！

* 今回つくるもの

.link https://twitter.com/golang/status/1106303553474301955 Goのアカウント

Gopherは @golang がリリースをつぶやくと
おもむろにGoをダウンロードしてGOROOTを切り替えるという習慣があります。
Gopherしぐさの１つです。

こういうのはDockerでやってたりする人もいると思いますし、すでに既存のコマンドであるgoenvというコマンドがありおそらく使っている人も多いと思います。

.link https://github.com/syndbg/goenv goenv

※goenvは他にGOPATHを切り替える同名のコマンドもあり、個人的には少し敬遠している。

* コマンド名は「golin」

オリンピックを来年に控えていますのでこの名前にしました！
名称にGoをつけてしまうのもGopherしぐさの１つです。

1. GOROOTを確認
2. 指定されたバージョンのGoを準備
3. currentというシンボリックリンクを指定したバージョンに切り替える

という動作で作ってみようと思います。

GOROOTをそのcurrentに設定しておけば、切り替えが簡単になるはず！


* help : go <command> [arguments]

まずはgoのhelpを見てみます。

    $ go help
          bug         start a bug report
          build       compile packages and dependencies
          clean       remove object files and cached files
          doc         show documentation for package or symbol
          env         print Go environment information
          ...     

ヘルプを打つとサブコマンドにどういったものがあるかがわかります。

    $ go help build

という感じでサブコマンドについても記述されていますし、gopathのようなサブコマンドにはない他の引数などもあります。


* version : print Go version

次はバージョンの確認です。

    $ go version
    go version go1.12 linux/amd64


現在のGoのバージョンをプリントてくれます。そのGoのビルドOSなどもわかります。
基本的にはGo1.12における話をしていきます。

このコマンドの性質上、実際のテスト中にGoのバージョンが古くなったりして困ったこともありました。
※例えば初期実装ではstrings.SplitAll()を利用していたけど、バージョンが古くなるとメソッドがなくて、コンパイルエラーが発生してしまうとか。


* デモ

実際にどのようになるか見てみましょう！

まずはコマンドをダウンロードして実行してみましょう！

* get : download and install packages and dependencies

ライブラリを使用したり、 コマンドを持ってきたりする時に使います

    $ go get golang.org/shizuokago/golin/cmd/golin

今回はコマンドを別ディレクトリにしているので名称が長いですが、
ライブラリを持ってくる時は

    $ go get golang.org/shizuokago/golin/

だけでOKです。
最新を取得する為に「-u」を入れることがほとんどです。


* Tips: コマンドの作り方

コマンドは実行形式になるのでmainパッケージである必要があります。

プロジェクトのルートをmainパッケージにして行うことも可能ですが、今回はcmd/golinというディレクトリを作成してそこにmainパッケージを作成しています。

    ProjectRoot
        |- cmd
            |- name           <- コマンド名
                |- main.go    <- ここにprojetを呼び出すソース
        |- package-source.go  <- ここにパッケージのソース

こんな感じです。

こうしておくと、例えばこのプロジェクトのコードを再利用したい時に、他のプロジェクトからライブラリとして呼ぶことが可能になります。
※mainパッケージだと他から見ることができない


* install : compile and install packages and dependencies

    $ go install .

install は$GOBINにインストールするコマンドになります。
$GOBINと言っていますが、$GOBINがなくても、$GOPATHがある場合に$GOPATH/binになります。

普段のGopherはGOPATHが存在する人が多いので$GOPATH/binになる方が多いと思います。なのでGOPATHがない状態で、GOBINを設定する人自体が少ないかもです。


* コマンドを実行してみる

ではgolinを実行してみましょう！

    $ golin list

これでダウンロードできるリストが表示されます。
実行には管理者権限(ディレクトリのsymblic linkを作成している為)が必要です。

    $ sudo golin 1.12.1

再度バージョンを見てみましょう！

    $ go version
    go version go1.12.1 linux/amd64

GolinはWindows(コマンドプロンプトを管理者権限にして)でも実行できます！
※Macでも試しています。なおsudoが絡むとGOROOTを見失ったりしますんで注意してください。(READMEに書いてあります)


* 使ってみる

* golinをライブラリとして使う

先程少し言いましたが、golinはライブラリとしても何個かAPIを公開しています。
ライブラリとしての使い方も見ていきましょう！

一旦demo.goを作成してみます。

.code demo.go


* fmt : gofmt (reformat) package sources

Goを書いたらfmtです。

    $ go fmt *.go

ソースをフォーマットしてくれます。
チーム開発時に戦争にならないのはとても良いと思います。
頑張ってきれいに整形してfmtで戻されるなんてこともあります。

おそらくIDE,エディタに保存時に動作するように埋め込んでおくのが吉かと思います。
詳細な引数を持つgofmtコマンドも存在します。


* vet : report likely mistakes in packages

   $ go vet .

ソースの簡単な問題を発見してくれます。
fmt.Printf()に対するオプションを間違っているとか、
structのタグを間違ってるなどがあります。潜在的なバグを発見してくれます。

テスト実行時など自動実行されてたりしてあんまり使わない。

* fix : update packages to use new APIs

    $ go fix

GoのAPIが新しくなった場合に修正してくれる。。。のですが、これで直ったことがないのでちょっとサンプルが提示できません。すみません。


* run : compile and run Go program

実際にコードを実行してみます。

    $ go run demo.go

同一階層(パッケージ内)でファイルが多くなった場合は

    $ go run .

とするとその階層の実行をしてくれます。(テストも排除してくれます)
※Go1.11からこの指定ができるようになりました。
これはmain関数が複数あるような階層だとエラーになります。

この実行方法がスクリプトっぽくてGoにハマったかもしれないと思ってます。


* clean : remove object files and cached files

コンパイル時に作成されるオブジェクトをクリーンしてくれます。
例えばcgoを呼び出したりしているとこれらを作成してキャッシュで使われることが多いです。

    go clean -cache

と行うとキャッシュを削除します。


* build : compile packages and dependencies

実行ファイルを作成する時は

    $ go build demo.go

という風に行います。

    $ go build -o demo .

実行単位が大きくなった場合は出力ファイルを指定しておかないとディレクトリ名がファイル名になってしまいます。
Windowsでの生成物はexeが付きます。

* 実は。。。

さらっと実行を行いましたが、Go1.11から大きく変更されている部分があります。
以前は実装に外部パッケージを利用した場合、

    demo.go:5:8: cannot find package "github.com/shizuokago/golin" in any of:

が発生していました。ないので当然ですね。
※今回は最初にデモやっているので、パッケージのソースがある状態になってますが、、、

現状のGoではこのようなことは起こりません（当然パッケージがないと起こります）

* Go Modules(基本編)

* Goの依存関係解決の道

Go 1.11から登場したGo Modulesはパッケージの依存関係を解決するもので
Goの依存関係解決は、

  make
  godep
  dep
  Go Modules(vgo) <- Now!

という感じで進化してきました。
※なんか抜けてるか？

私はgodep時代にそろそろ真面目に、、、って思った次のタイミングでdepの話が出てからおざなりになってしまいました。


* GO111MODULE

GO111MODULEはこの動作のための環境変数です。
現在(1.12)はまだ正式リリースではなく、移行段階に入っている状態です。

   1.11 -> off
   1.12 -> auto
   1.13 -> on

とデフォルトになる予定(現状はauto)です。
Go1.11のonとGo1.12のonにも違いがあるので注意が必要です。
後述するgo.modファイルがないとgo getができないとか


* GOPATH mode(GO111MODILE=off)

おそらく古いブログ、メンテされてないライブラリなどはインストール方法などはこのモードで書かれていたりしますので、その通りにやると動かない状態などが出てくるかもしれません。
※メンテされているリポジトリはすでにdep化なども行っていて、すでにModulesに移行できていることが多いと思います。

$GOPATH/srcですべて管理される為、別のプロジェクトから違うバージョンを使いたい場合(いわゆるGOPATH汚染)などで困っていました。その為、プロジェクト内でGOPATHを指定したり、vendorなどを利用して管理していました。

* Tips : GOPATH

環境変数GOPATHがないと動かない。みたいな文献もありますが、Go1.8以降は環境変数GOPATHがない状態では、ユーザのディレクトリにgoというディレクトリを作成し、そこをGOPATHとみなす動作をします。

GolinもGOPATHを見る必要がある為、考慮して動作しています。
※バグがあります

* Hybrid Mode?(GO111MODULE=auto)

現状1.12は指定がない場合、このモードで動作します。
GOPATH配下での動作はoff、それ以外はonで動作します。

移行中で関連が複雑になる為の配慮だと思われます。

* module aware mode(GO111MODULE=on)

Go1.13からはこのモードで動作しますので今後GOPATH modeはいやでも使用しなくなります。 
※いやならoffするんですけど、、、

今日は少なくともModuleの基礎だけは覚えていっていただければな。と思います。

* Modulesの動作

Go Modulesは関連が必要になった時に動作する為

    go run .
    go build .
    go test .
    go get .
  
辺りのコマンドで自動的に動作します。

* go.mod

Go Modulesで自動的に作成されるgo.modファイルの中身です。

    module handout
    
    go 1.12
    
    require github.com/shizuokago/golin v1.0.0 // indirect 

対象のモジュール名と、使用しているGoのバージョン、使用しているパッケージが表示されます。
基本的には自動的に処理されるので直接見ることはないかと思います。

モジュール名はgitリポジトリだとremoteが自動で入る仕様が（多分）あります。

* list : list packages or modules

パッケージの一覧を表示するコマンドになります。

    go list -m all

そのモジュールが使用しているパッケージの一覧を表示してくれます。(-mは1.12.1から

    go list all

も使えるのですが、これは使用できるパッケージの一覧が出るだけです。


* Go Modules(利用編)

* バージョン依存

すべてのプロジェクトが「常に最新のもの」を見る場合は問題ないのですが、
別のプロジェクトが同じライブラリを使用して、新しいバージョンを見たいけど、こっちは古いバージョンを使いたい。とか、他の人がgo getで取って来た場合に指定のバージョンで動作させたい。というような時に単純なGOPATHモードでは不可能でした。

そのため手元を個別のGOPATHにして管理していました。

golinを利用して、バージョンによる挙動の変化を起こして見ましょう。

* バージョンの付け方

ライブラリ作成側の観点になりますが、提供している側はgitでタグを打つことで、バージョンによる提供を行うことができます。 

.link https://semver.org/ semantic versioning

gitに[vX.X.X]というタグを作ることでバージョンを指定して呼び出すことも可能です。呼び出してみましょう！

  go get -u github.com/shizuokago/golin@v0.8.0

とすることでv0.8.0を使用するよ。と宣言できます。

* 指定可能バージョン

go.mod内を見てみるとv0.8.0を使用するような変更が加わります。

    golin@v1.0.0
    golin@v0.8.0+incompatible

リポジトリの指定可能バージョンは

    $ go list -m -versions

とすることで見ることが可能です。

* 実際の管理場所

GoModulesにより単一のGOPATH上で管理できるようになります。
GOPATH/pkg/modを見てみましょう。

GOPATH Mode時と同じ管理っぽく見えますが、最後のモジュール部分で

    @バージョン

という感じで表示されるはずです。

タグが存在しない場合はv0.0.0 - コミットハッシュとなります。
ハッシュ値での指定も可能で明示的にHEADにしたい場合、@masterなどが使えます


* V2,V3が出てきた場合 

今までv2,v3などが現れた場合、ライブラリ側がそのソースを残しておく必要があったのですが、

    import (
         //"rsc.io/quote"
         "rsc.io/quote/v3"
         //"rsc.io/quote/v2"
    )

として使用するバージョンを指定できるようになりました。
逆にライブラリ側はそういう管理方法をしては行けなくなります。

※gopkg.in/ldapはldap.v3などで指定が可能になっていて、資料にも.v2などでの記述もあり詳細は不明


* mod : module maintenance

    $ go mod tidy 

で無駄な関連性があるものを削除してくれます。

そのほかの引数としてvendorなどの設定も可能になっています。

* ローカルパッケージを使うパターン

   my.go
       local/
           local.go

という構成の場合、以前はimportに

   "./local"

という相対パスで埋め込んでいましたが、現在は

   $ go mod init xxxxx

で自分をxxxxxパッケージにしてimportで

   xxxxx/local 

として、実行が可能です。

* Tips : ソースの配置方法

例えば(私がそうなのですが) src下にソースを置きたい人なんですが、ライブラリを作成する場合、パッケージルートは直接おいた方がいいです。

なぜなら使う側のimport文が

    import (
        github.com/xxxx/yyyy/src
    )

とまぁちょっとカッコ悪い感じになってしまうのです。

ライブラリはそう言えるんですが、例えばAppEngineのプロジェクトなんかもディレクトリ構成等を考える必要があります。

先程のローカルパッケージの保存方法を利用してなにか構成を考えてみたいと思います。(後日


* コードを見てみよう！

* ダウンロードする仕組み

再度Golinに戻ります。
Goをダウンロードしている仕組みはつぶやきにもあったように

    $ go get golang.org/dl/go1.12.1

と行うと「go1.12.1」という実行ファイルがインストールされます。
このファイルを

    $ go1.12.1 download

と実行するとユーザのディレクトリ配下にsdk/go1.12.1を作成し、そこにgoのSDKが一式ダウンロードされる仕組みになっています。
ここで「GOPATH/bin」の値をみたいところですが、前述したとおり、GOPATHは設定されてないユーザもいるので、環境変数値から値をとることはできません。

* env : print Go environment information

そんな時の為にenvというサブコマンドがあります。
パスが欲しい場合は

    $ go env GOPATH

が確実に取得することが可能です。

またこのコマンドは

    $ go env

で一覧を取得したり、-jsonでjsonで取得したりもできます。

* Tips: さまざまな変数

go env はビルド関連の値を多く管理しています。


先程説明した、go.modが自分の階層にない場合、上位ディレクトリのgo.modを参照しますので、

    $ go env GOMOD

で現在参照しているmodファイルの位置だったりを取得できます。



* OSでの違い

ディレクトリのシンボリックリンク作成コマンドは

Windowsは

    # mklink /D current go1.12

Linux(UNIX系)のシンボリックリンク作成コマンド

    # ln -sd go1.12 current

という風になってます。

* そんな時は！！！

osパッケージが吸収してくれることがあります。（いやきっと解決してくれます

例えばこの場合は、

   os.Symlink("go1.12","current")

と行うと２つの違いを吸収してくれます。

   //linux mv, windows move
   os.Rename(old,new) 

なんかも差分を吸収してくれます。

今回知りましたが、コマンドを直接打った場合、Windowsのrmdir,moveはPATH上には存在しないので、コマンドとして打てないようです。

* 他の代表的な例

ファイルパスを扱う場合は

    path/filepath

を利用して、[\]と[/]の問題などを解消してくれます。
ファイルパスを連携する時は

    filepath.Join(dir,"test.txt")

と実装しておくとこの問題が解決します。

* Tips : filepath.Glob()

いつも「あっこれつくったろ！」と一瞬思い、思い出すAPIがあります。

    filepath.Glob(pathRg)

です。

単純に引数に「*.txt」とすると対象を検索してくれるだけなんですけど、重宝します。

golinでも少し使用していて、バージョンリストを作成する際にディレクトリの名前で一覧を作成するわけですが、ダウンロードしてきた値がsrc固定ではない為、「mod/pkg/golang.org/dl@*」で検索しています。

* 標準パッケージで解決できない場合

ユーザのディレクトリにSDKをダウンロードした後に、正規の場所に移動する必要があります。ただユーザのディレクトリはWindows以外には環境変数HOMEに入りますが、WindowsはUSERPROFILEに入ります。

そういう時は

    runtime.GOOS

という値にOSを表す文字列が入ります。これをif文で判定するわけです。

    if runtime.GOOS == "windows" {
        home = os.Getenv("USERPROFILE")
    } else {
        home = os.Getenv("HOME")
    }

という感じです。

実際にはPlan9にはHOMEの概念がないらしくPlan9では動作しないかも、、、


* 別の方法(今回の方法

あまりにもこういう条件式が多いとソースが美しくない状態になるかもです。
そんな時はOS別にファイルを作成します。

golin_windows.go
golin_other.go

というファイルを作って

    // +build windows

もしくは

    // +build !windows

とヘッダ部分に記述します(CSVで複数設定できます)。これはコメント間で１行あけて記述する必要があります。忘れていると微妙にハマるので注意が必要です。

こうすることでWindowsの時、Windowsじゃない時でビルドされるファイルが変わります。

* 呼び出し側

後は依存しないコード側に

    home := getHome()

と分ける対象の関数を呼び出しをしてあげるだけでOKです。
そうするとビルド環境によってコンパイルを切り替えてくれます。

条件がOSじゃない場合でも例えば

    // +build appengine

としておいて

    go build -tags appengine

と独自のタグを指定することも可能です。


* テストを書いてみよう！

* test : test packages

Goはテストも同梱していて

    $ go test ./...

でテスト実行が可能です。
xxxxx_test.goというsuffixでファイル名で作成し、

    package yyyy_test

    import "tesiting"

    func TestZzzz(t *testing.T) {
    }

TestZzzz()のという名称の関数で引数を*testing.Tにして上げることでテスト対象となります。
※特例としてパッケージ名「yyyy_test」はyyyyパッケージに同居できます。

* Tips : 別パッケージでテスト

私自身privateのテストは行わない主義なのですが、何故かgoのテストについては同じパッケージで書くことが多かったです。多分同一ディレクトリ内に同じパッケージ名の感覚が強いのかもしれません。

今回作成するにあたって（とくにライブラリ）、外部パッケージにした方が、使用方法がわかる。ということに気づきました。同一パッケージでは

    path := GetGoEnv("GOPATH")
    if path == "" {
        t.Errorf("There is no reason why my GOPATH is empty")
    }

というテストになるのですが、別パッケージだと

    path := golin.GetGoEnv("GOPATH")
    if path == "" {
        t.Errorf("There is no reason why my GOPATH is empty")
    }

となって実際に使う時と同じ感じに書けます。

* 準備の動作

setup的な処理を行いたい場合はTestMain()を実装します。

    func TestMain(m *testing.M) {
        os.Exit(m.Run())
    }

と書いておくと、通常のテスト動作と同じになります。
fail時にコマンドがエラーを返すようにos.Exit()に戻り値を返してあげます。

今回はテスト時にGOROOTをいじってテストするので一旦作業ディレクトリなどを作成しています。


* 遅いテストをスキップする

今回のコマンドはテスト時にダウンロードしたりもするので、テストがかなり時間がかかります。
2分くらいでは終わりますが、他のテストを追加したい時などはリズムが悪いのでShortモードを利用します。
※ネットワーク遅い場所で10分超えてテストがコケた

時間のかかるテストに対して

    if testing.Short() {
        t.Skip("skipping Download() test in short mode.")
    }

と書いて

    $ go test -short .

と実行するとテストをスキップしてくれます。


* ベンチマーク

Goのテストではベンチマークを取ることができます。
今回は大半の部分はIOの部分が多いので、劇的に早くなってもたかがしれていますが唯一処理っぽいことをしているバージョン周りのベンチマークを取ってみます！

    func BenchmarkParseVersion(b *testing.B) {
        for i := 0; i < b.N; i++ {
             golin.NewVersion("1.12.1")
        }
    }

prefixにBenchmarkXxxxxを作成し、引数を*tesitng.Bにしてあげます。
ループ値にb.Nを使用することでループ値を勝手に設定してくれます。
※トータル１秒くらいの値でループします

    BenchmarkParseVersion-8          1000000              1029 ns/op

1回のループに1029nsかかっている（実際のコードではNewVersion()を５回やってる）状態です。

* Tips : sort

スライスのソート処理は以前に比べると簡易になりました。

    sort.Slice(target,func(i,j int) int {
        ti,tj := target[i], target[j]
        return target[i] > target[j]
    })

という感じです。
プリミティブな型のスライスのソートは「Ints(),Strings()」などが提供されています。

今回はバージョンの表示の際にディレクトリ名順になっているところに並び替えを行っています。
ここにもベンチマークを入れて測っています。

    BenchmarkSortVersion-8              1000           1726996 ns/op

10000件のソートに1msなので、、、まぁいいかな？

* ちゃんと計測する

前処理などを含めてしまうと関数の純粋な処理時間等を図ることができません。
例えばソートの処理は１万件のデータ生成がありますので、その部分は計測しない方が純粋なソート時間を計測できます。(5件で1nsかかっているので、前処理で+2000ns以上かかる計算

なので前処理後に

    b.ResetTimer()

を呼び出して、純粋にソートに対する処理にのみ計測を行うようにしています。


* ベンチマークの処理回数

ベンチマーク自体の回数を指定するには

    $ go test count=1 .

と行うことができます。

処理自体には揺れがあるので、何度か処理を行ってみるのもいいと思います。
またテストが実装のみの変更時にキャッシュで動作してしまう場合があります。

    ok      github.com/shizuokago/golin     (cached)

このような時に明示的にcountを1にして動作させるというハックもあります。
※ハックと思ってたけどhelpに書いてあった

* 標準出力のテスト

標準出力のテストを行うことができます。
Exampleは標準出力のテストで

    func ExampleCreate() {
       
        golin.Create("list")
    
        // Output:
        // 出力する文字列
    }

とOutputをコメントに書いてテストすることができます。

* Exampleの命名規則

またExampleは後述するドキュメントの要素である為、関数名に細かい命名規則があります。

    Example()
    ExampleF()
    ExampleT()
    ExampleT_M()

とすることでドキュメントとして扱うことができますが、
ドキュメントとしても機能して、名称を替えたい場合は

    Example_suffix()
    ExampleF_suffix()
    ExampleT_suffix()
    ExampleT_M_suffix()

と小文字の_suffixをつけることができます。

* Tips : 標準入力

コマンド作成の時は、標準入力が絡むテストを行う事が多いと思います。
標準入力を行う箇所をio.Readerで利用しておいて、呼び出し側で切り替えられるようにしておくとテストがしやすいです。

    stdin := bytes.Buffer("\n")
    r := golin.Create(stdin) //実際の引数と違います

例えばこうしておくと「何も入力されなかった時のテスト」が可能です。


* ドキュメントを書いてみよう！

* doc : show documentation for package or symbol

doc コマンドはパッケージの仕様を表示するサブコマンドです。
例えば

    go doc sort

とすると、sortのパッケージの仕様が出てきます。
型やなども見るには

    go doc -all sort

とやることができます。

privateも見たい場合は

    go doc -u sort

になります。

* 自分のドキュメントを見てみる

パッケージ名を抜くと作業中のパッケージを見ることができます。
メソッド名を記述するとメソッドだけを見ることができます。

パッケージの説明文などはどこに書いていいか難しいのでdoc.goなどを作っておいて、そこに記述するようにしても良いでしょう。


* 先頭行が大事

ドキュメントを書く場合の最重要ポイントは
英字大文字で開始する。これが大前提になります。

あとシンボルに対して空行があると、そのシンボルのコメントとして認識してくれませんのでくっつけて書きましょう

あと

   /*
    * <- ここ
    */

もドキュメントになるので装飾には注意です。

* BUG(who) :

これはパッケージの最後にドキュメントに残ります
何か問題があった場合は書いて置くと良いでしょう。

カッコ内に担当者を書くようになっています。


* Tips : mainの場合

コマンドを書く場合はmainパッケージになります。
mainパッケージは特殊で実行ファイルを作る用ですので基本的に「他のパッケージから呼ばれることがない」パッケージになる為、メソッドの記述が出てきません。

どうしても出力したい場合は

    go doc -cmd

としてもOKですが、すべて出したい(詳細な仕様書のようなもの)を出力したい時のような気がするので

    go doc -u -all

としてすべて出力した方がよいでしょう。


* Web表示してみよう！

godoc(先日サポート完了が発表された)コマンドが存在し、内部でサーバを起動することが可能です。
起動するとパッケージのすべてが表示できる状態になります。

    godoc 

とすると、GOPATH内にあるすべてのパッケージのドキュメントを見ることが可能になります。(デフォルトポートは6060)

まぁ1.13では標準に乗らないということになっているので、その際はgo getしましょう。
※その為go docの引数が-allをサポートするようになったりしています。

* ラベルの扱い

BUG():はありましたが、何らかのルールを決めて
これはドキュメントとしては動作はしてませんが、特殊な扱いをすることができます。

例えば

     // TODO(who):

として、

    godoc -notes=".*"

とするとTODOもラベルとして扱ってくれます。

    Deprecated:

が少し特殊でGoLandなどのIDEでサポートしていたりします。(使っている時に動いてびっくりした。
TODOとDeprecatedは標準パッケージにも良く使われています。


* 公開する

公開されたライブラリはgodoc.orgにドキュメントを公開することが可能です。

.link  https://godoc.org/github.com/shizuokago/golin

に公開されます。GitHubに公開すればというわけではなく、

.link https://go-search.org/ Go-Search

で登録しておく必要があります。
※第三者でも検索したら探して追加してくれる感じ

更新についてはドキュメントの下で即時リフレッシュがあるようですが、一定期間で巡回してくれているらしく、押したことはないです。

* その他のサブコマンド

* bug : start a bug report

    $ go bug 090-xxxx-xxxx

とうつとGoogleから電話がかかってきてバグの位置を聞かれます。。。ではなくて、GitHubのgoのリポジトリのissueページがブラウザで立ち上がります。※電話番号は必要ありません

電話の下りはジョークですが、何が起こるかわからないので正直、打ってみるのが怖かった。

* generate : generate Go files by processing source

本日静的解析で @hogedigo が少し話したと思いますが、タグベースで処理を行うことができるものです。
おそらく一番有名なので

    golang.org/x/tools/cmd/stringer

でして、stringerコマンドを行うと、構造体にString()メソッドを作ってくれます。

    //go:generate stringer -type=Name
    type Name struct {
    }

としておくとgo generateされると、勝手にstringerが呼ばれて更新されます。


* tool : run specified go tool

基本的にサブコマンドが発表される前にここで実装されていることが多いです。

例えば go fixも細かいオプションを使いたければtoolで

    $ go tool fix

を実行します(実際の呼び出しもcmd/go/internal/base.Tool("fix")って感じで同じ処理を呼んでいます)。go vetなんかもそうですね。

* Tips : ログを残そう！

Goにはlogパッケージが存在し、ログを残せるようにはなっています。低レベルのものしか基本的には提供してないので、便利なライブラリを探そうとしちゃいそうですが、ライブラリを書く場合はそれらは使わない方が良いと私は考えています。

って誰かが言ってました。

「ユーザはあなたのライブラリを使いたいのであって、あなたのログライブラリを使いたいわけではない」

うんいい言葉です。

結局golinではlogは使いません(やる時間がなかった)でした。


