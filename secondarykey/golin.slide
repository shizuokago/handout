コマンドを作ってみては？
Shizuoka.go Vol.13
30 Mar 2019
Tags:golang

secondarykey
Programmer
https://github.com/secondarykey/
@secondarykey

* Tourを終えた人へ

Tour of Go をやり終えて簡単な言語仕様は把握したところでコマンドでも作ってみれはどうかな？という提案めいた発表です。

Go は簡単にHTTPサーバを立てたりもできますが、さまざまなプラットフォームでの動作もできるGoでコマンドを作ってみたいと思います。コマンドを作りながらGoでソフトを作る時のTipsやGoのサブコマンドの使い方などでGoの魅力を紹介できたらなぁと思います。

なんか書き足して行ったら、かなりのページ数になりました。
何か作ったことのある人でも３回位へぇって言える箇所があればなぁと思います。


* いろいろできるGo言語

少しいままで作ってきたものを紹介したいと思います。
私の場合は仕事ではなく、仕事上でのツールを作ることが多く、Goはすごく重宝しています。

あまりにもメンテナンスをしていなくて、ほぼ死んでるのでメンテしてかないと。。。と思いながら開いて「わぁ」ってなって閉じていることが多いです。

Goではいろんなことができるのが伝われば幸いです。


* github.com/shizuokago/blog

GAE/Goのブログエンジン

GopherJSでエディタを作成していてちょっと最近触ろうと思ったんだけど、GopherJSどころかjQuery依存していて、移行できるか心配。

GopherJSはGo言語でJavaScriptを動作させる仕組みで、開発当初はかなりのキワモノだと思っていましたが、現在もメンテナンスをされており、いろんな場所で活躍しているみたいです。
JSファイル自体が重い(少なくとも昔は)ので、普通のサイトに対して適用するものではないかも

* github.com/secondarykey/speaks

Simple SNS

閉ざされたネットワーク上のレガシーな現場でチャットシステムを導入するべく作ったチャットシステム。

HTTPだけではなくWebSocketも気軽にサーバを立ち上げることが可能です。

先日、jQueryを排除してMDL化しました。ActiveDirectoryアクセスを可能にしてより簡単に導入できるようにしています。

ただ冷静に考えたらWebSocketではなく、gRPC化をしたほうがかっちょええってことに気付いて現在設計中。


* github.com/shizuokago/gopredit

GAE/GoでGoのpresentionツールをサービス化してみたものです。
先日動かしてみたら見事に動きませんでした。かなり初期に作ったのでソース見たらボロボロでした。(panicの連発

テストフレームワークも使っていて、なにやらボロボロです。

現在この資料も含めて管理方法を模索中でして、簡単にプレゼンをまとめれたらなぁと思っています。


* github.com/secondarykey/dizzy

先程説明のあった静的解析を行ってDatastoreに簡易的にアクセスする為に作成したもの。
ちょうど実装中に少し大きなものを作成開始してしまい、それに適用しなかった為、実運用をのがした悲しいツール

内部でtestを自動実行する仕組みを持っていて、それをツール化して抜き出したい。


* github.com/secondarykey/davgo

WebDAVアクセスを行った時に使ったもの。
久しぶりに見たら案外コードが書いてあって、全部自分でコーディングしたのか怪しい。(サンプル持ってきただけ？

某社の某ストレージサービスへのAPI公開時に作ったもの。ﾁﾗﾁﾗ

* github.com/secondarykey/yuru

某パズルゲームの計算アルゴリズムを作成しました。
アルゴリズムの勉強用ではあったのですが、チューニング等の勉強をした記憶もある

本当はGoMobileと連携して、パズルゲームシュミレーターみたいなものにしようと思ってたけど、現在暗礁に乗り上げています。

* github.com/ikascrew/ikascrew

いわずとしれたVJ イカスクリューを支えるVJ System。

opencvを利用した動画表示、切替を行う仕組みであり、Shinyによる表示などができないか？などを作成してみたりしたこともある。

最近VJをやってないので少し放置気味ですが、go-opencvからgocv.ioに変更を行いました。

本当は動画データベースを作り込みたい


* github.com/ikascrew/xbox

USBのゲームコントローラーのイベントを拾うライブラリ。

動画操作の為に作成したものではあるが、実はこのコード(ライブラリを使いやすくしただけですが)を書いた後にアメリカ海軍がXBOXのコントローラーを採用しました。

製造業の現場などで使われる可能性も視野に入れていいかもなぁなんて思ってます。

実はオリジナルでトグルを作成し、ボリュームコントローラーなどを自作しようかな？などと思っています。


* その他

FTPベースでファイルを同期するmysyncというものも存在するのですが、それはとある世界線にしか存在しません。

その仕組みを使っているシステムは、開発環境自体の仕組みが特殊で特有の同期を行います。



* Let's Go！

* 今回つくるもの

.link https://twitter.com/golang/status/1106303553474301955 Goのアカウント

Gopherは @golang がリリースをつぶやくと
おもむろにGoをダウンロードしてGOROOTを切り替えるという習慣があります。
Gopherしぐさの１つです。

こういうのはDockerでやってたりする人もいると思いますし、すでに既存のコマンドであるgoenvというコマンドがありおそらく使っている人も多いと思います。

.link https://github.com/syndbg/goenv goenv

※goenvは他にGOPATHを切り替える同名のコマンドもあり、個人的には少し敬遠している。

* コマンド名は「golin」

オリンピックを来年に控えていますのでこの名前にしました！
名称にGoをつけてしまうのもGopherしぐさの１つです。

1. GOROOTを確認
2. 指定されたバージョンのGoを準備
3. currentというシンボリックリンクを指定したバージョンに切り替える

という動作で作ってみようと思います。

GOROOTをそのcurrentに設定しておけば、切り替えが簡単になるはず！


* help : go <command> [arguments]

まずはgoのhelpを見てみます。

    $ go help
          bug         start a bug report
          build       compile packages and dependencies
          clean       remove object files and cached files
          doc         show documentation for package or symbol
          env         print Go environment information
          ...     

ヘルプを打つとサブコマンドにどういったものがあるかがわかります。

    $ go help build

という感じでサブコマンドについても記述されていますし、gopathのようなサブコマンドにはない他の引数などもあります。


* version : print Go version

次はバージョンの確認です。

    $ go version
    go version go1.12 linux/amd64


現在のGoのバージョンをプリントてくれます。そのGoのビルドOSなどもわかります。
基本的にはGo1.12における話をしていきます。

このコマンドの性質上、実際のテスト中にGoのバージョンが古くなったりして困ったこともありました。
※例えば初期実装ではstrings.SplitAll()を利用していたけど、バージョンが古くなるとメソッドがなくて、コンパイルエラーが発生してしまうとか。


* デモ

実際にどのようになるか見てみましょう！

まずはコマンドをダウンロードして実行してみましょう！

* get : download and install packages and dependencies

ライブラリを使用したり、 コマンドを持ってきたりする時に使います

    $ go get http://golang.org/shizuokago/golin/cmd/golin

今回はコマンドを別ディレクトリにしているので名称が長いですが、
ライブラリを持ってくる時は

    $ go get http://golang.org/shizuokago/golin/

だけでOKです。
最新を取得する為に「-u」を入れることがほとんどです。


* Tips: コマンドの作り方

コマンドは実行形式になるのでmainパッケージである必要があります。

プロジェクトのルートをmainパッケージにして行うことも可能ですが、今回はcmd/golinというディレクトリを作成してそこにmainパッケージを作成しています。

    ProjectRoot
        |- cmd
            |- name           <- コマンド名
                |- main.go    <- ここにprojetを呼び出すソース
        |- package-source.go  <- ここにパッケージのソース

こんな感じです。

こうしておくと、例えばこのプロジェクトのコードを再利用したい時に、他のプロジェクトからライブラリとして呼ぶことが可能になります。
※mainパッケージだと他から見ることができない


* install : compile and install packages and dependencies

    $ go install .

install は$GOBINにインストールするコマンドになります。
$GOBINと言っていますが、$GOBINがなくても、$GOPATHがある場合に$GOPATH/binになります。

普段のGopherはGOPATHが存在する人が多いので$GOPATH/binになる方が多いと思います。
なのでGOPATHがない状態で、GOBINを設定する人自体が少ないかもです。


* コマンドを実行してみる

ではgolinを実行してみましょう！

    $ golin list

これでダウンロードできるリストが表示されます。
実行には管理者権限(ディレクトリのsymblic linkを作成している為)が必要です。

    $ sudo golin 1.12.1

再度バージョンを見てみましょう！

    $ go version
    go version go1.12.1 linux/amd64

GolinはWindows(コマンドプロンプトを管理者権限にして)でも実行できます！
※Macでも試しています。


* 使ってみる

* golinをライブラリとして使う

先程少し言いましたが、golinはライブラリとしても何個かAPIを公開しています。
ライブラリとしての使い方も見ていきましょう！

一旦demo.goを作成してみます。

.code demo.go

※Create()は権限もいるので他のメソッドを利用しています。


* fmt : gofmt (reformat) package sources

Goを書いたらfmtです。

    $ go fmt *.go

ソースをフォーマットしてくれます。
チーム開発時に戦争にならないのはとても良いと思います。
頑張ってきれいに整形してfmtで戻されるなんてこともあります。

おそらくIDE,エディタに保存時に動作するように埋め込んでおくのが吉かと思います。
詳細な引数を持つgofmtコマンドも存在します。


* vet : report likely mistakes in packages

ソースの簡単な問題を発見してくれます。

fmt.Printf()に対するオプションを間違っているとか、structのタグを間違ってるなどがあります。


* fix : update packages to use new APIs

    $ go fix

GoのAPIが新しくなった場合に修正してくれる。。。のですが、これで直ったことがないのでちょっとサンプルが提示できません。すみません。


* run : compile and run Go program

実際にコードを実行してみます。

    $ go run demo.go

同一階層(パッケージ内)でファイルが多くなった場合は

    $ go run .

とするとその階層の実行をしてくれます。(テストも排除してくれます)
※Go1.11からこの指定ができるようになりました。
これはmain関数が複数あるような階層だとエラーになります。

この実行方法がスクリプトっぽくてGoにハマったかもしれないと思ってます。


* clean : remove object files and cached files

コンパイル時に作成されるオブジェクトをクリーンしてくれます。
例えばcgoを呼び出したりしているとこれらを作成してキャッシュで使われることが多いです。

    go clean -cache

と行うとキャッシュを削除します。


* build : compile packages and dependencies

実行ファイルを作成する時は

    $ go build demo.go

という風に行います。

    $ go build -o demo .

実行単位が大きくなった場合は出力ファイルを指定しておかないとディレクトリ名がファイル名になってしまいます。
Windowsでの生成物はexeが付きます。

* 実は。。。

さらっと実行を行いましたが、Go1.11から大きく変更されている部分があります。
以前は実装に外部パッケージを利用した場合、

    demo.go:5:8: cannot find package "github.com/shizuokago/golin" in any of:

が発生していました。ないので当然ですね。
※今回は最初にデモやっているので、パッケージのソースがある状態になってますが、、、

現状のGoではこのようなことは起こりません（当然パッケージがないと起こります）

* Go Modules(基本編)

* Goの依存関係解決の道

Go 1.11から登場したGo Modulesはパッケージの依存関係を解決するもので
Goの依存関係解決は、

  make
  godep
  dep
  Go Modules(vgo) <- Now!

という感じで進化してきました。
※なんか抜けてるか？

私はgodep時代にそろそろ真面目に、、、って思った次のタイミングでdepの話が出てからおざなりになってしまいました。


* GO111MODULE

GO111MODULEはこの動作のための環境変数です。
現在(1.12)はまだ正式リリースではなく、移行段階に入っている状態です。

   1.11 -> off
   1.12 -> auto
   1.13 -> on

とデフォルトではなる予定(現状はauto)です。
Go1.11のonとGo1.12のonにも違いがあるので注意が必要です。
※GOPATH以外での実行が不可

* GOPATH mode(GO111MODILE=off)

おそらく古いブログ、メンテされてないライブラリなどはインストール方法などはこのモードで書かれていたりしますので、その通りにやると動かない状態などが出てくるかもしれません。

メンテされているリポジトリはすでにdep化なども行っていて、すでにModulesに移行できていることが多いと思います。

単一のGOPATHで管理していると、別のプロジェクトから違うバージョンを使いたい場合に問題が起こっていました。その為、プロジェクト内でGOPATHを指定したり、vendorなどを利用して管理していました。

* Tips : GOPATH

環境変数GOPATHがないと動かない。みたいな文献もありますが、Go1.8以降は環境変数GOPATHがない状態では、ユーザのディレクトリにgoというディレクトリを作成し、そこをGOPATHとみなす動作をします。

GolinもGOPATHを見る必要がある為、考慮して動作しています。

* Hybrid Mode(GO111MODULE=auto)

現状1.12は指定がない場合、このモードで動作します。
GOPATH配下での動作はon、それ以外はoffで動作します。

なんか気持ち悪いのでデフォルトよりはonにしておくのがよいと思います。

* Go Module(GO111MODULE=on)

Go1.13からはこのモードで動作します。 今後GOPATH/srcは使用しなくなります。 
今日は少なくともModuleの基礎だけは覚えていっていただければな。と思います。

* Modulesの動作

Go Modulesは関連が必要になった時に動作する為

    go run .
    go build .
    go test .
    go get .
  
辺りのコマンドで動作を行います。


* go.mod

Go Modulesで自動的に作成されるgo.modファイルの中身です。

    module github.com/shizuokago/handout
    
    go 1.12
    
    require github.com/shizuokago/golin v1.0.0 // indirect 

対象のモジュール名と、使用しているGoのバージョン、使用しているパッケージが表示されます。
基本的には開くことはないです。


* list : list packages or modules

パッケージの一覧を表示するコマンドになります。

    go list -m all

そのモジュールが使用しているパッケージの一覧を表示してくれます。(-mは1.12.1から

    go list all

も使えるのですが、これは使用できるパッケージの一覧が出るだけです。




* Go Modules(利用編)

* バージョン依存

すべてのプロジェクトが「常に最新のもの」を見る場合は問題ないのですが、
別のプロジェクトが同じライブラリを使用して、新しいバージョンを見たいけど、こっちは古いバージョンを使いたい。とか、他の人がgo getで取って来た場合に指定のバージョンで動作させたい。というような時に単純なGOPATHモードでは不可能でした。

そのため手元を個別のGOPATHにして管理していました。

golinを利用して、バージョンによる挙動の変化を起こして見ましょう。

* バージョンの付け方

ライブラリ作成側の観点になりますが、提供している側はgitでタグを打つことで、バージョンによる提供を行うことができます。 

.link https://semver.org/ semantic versioning

gitに[vX.X.X]というタグを作ることでバージョンを指定して呼び出すことも可能です。呼び出してみましょう！

  go get -u github.com/shizuokago/golin@v0.8.0

とすることでv0.8.0を使用するよ。と宣言できます。
go.mod内を見てみるとv0.8.0を使用するような変更が加わります。

    goli@v1.0.0
    goli@v0.8.0+incompatible


* 実際の管理場所

GoModulesにより単一のGOPATH上で管理できるようになります。
GOPATH/pkg/modを見てみましょう。

GOPATHMode時と同じ管理っぽく見えますが、最後のモジュール部分で
GOPATH/pkg/mod/github.com/shizuokago内に


という感じで表示されるはずです。
タグが存在しない場合はv0.0.0 - コミットハッシュとなります。


* ハッシュ値での指定

コミットのバージョンでも指定可能になっています。
hgではわかりませんが


* mod : module maintenance

    go mod tidy 

で無駄な関連性があるものを削除してくれます。

   go clean -cache 

でキャッシュは削除可能です。


* ローカルパッケージを使うパターン

自分だけのパッケージを使いたい時です。





* Tips : ソースの配置方法

ライブラリを作成する場合、パッケージルートが望ましいです。
例えば(私がそうなのですが) src下にソースを置きたい人なんですが、
ライブラリとして取得する場合に

    go get github.com/xxxx/yyyy/src

とまぁカッコ悪い感じになってしまうのです。
ちょっと後でパッケージの話もあるので詳細はそこで話していきましょう。

* Tips : ログを残そう！

Goにはlogパッケージが存在し、ログを残せるようにはなっています。低レベルのものしか基本的には提供してないので、便利なライブラリを探そうとしちゃいそうですが、ライブラリを書く場合はそれらは使わない方が良いと私は考えています。

どっかで誰かが言ってました。

「ユーザはあなたのライブラリを使いたいのであって、あなたのログライブラリを使いたいわけではない」

うんいい言葉です。

・・・とはいえ、覇権に一番違いのはglogだと思います。




* コードを見てみよう！

* ダウンロードする仕組み

Goをダウンロードしている仕組みはつぶやきにもあったように

    $ go get golang.org/dl/go1.12.1

と行うと「go1.12.1」という実行ファイルがインストールされます。
このファイルを実行するとユーザのディレクトリ配下にsdk/go1.12.1を作成し、そこにgoのSDKが一式ダウンロードされる仕組みになっています。

ここで「GOPATH/bin」の値をみたいところですが、先述したとおり、GOPATHは設定されてないユーザもいるので、環境変数値から値をとることはできません。


* env : print Go environment information

そんな時の為にenvというサブコマンドがあります。
パスが欲しい場合は

    $ go env GOPATH

が確実に取得することが可能です。

またこのコマンドは

    $ go env

で一覧を取得したり、-jsonでjsonで取得したりもできます。


* みなさんはご存知ですか？

ディレクトリのシンボリックリンク作成コマンドは

Windowsは

    # mklink /D current go1.12

Linux(UNIX系)のシンボリックリンク作成コマンド

    # ln -sd go1.12 current

という風になってます。

これらを使い分けを


* そんな時は！！！

osパッケージが吸収してくれることがあります。（いやきっと解決してくれます

例えばこの場合は、

   os.Symlink("go1.12","current")

と行うと２つの違いを吸収してくれます。

   os.Rename(old,new) : linux mv, windows move

なんかも差分を吸収してくれます。

今回知りましたが、コマンドを直接打った場合、Windowsのrmdir,moveはPATH上には存在しないので、コマンドとして打てないようです。


* 他の代表的な例

ファイルパスを扱う場合は

    path/filepath

を利用して、[\]と[/]の問題を解消してくれます。
ファイルパスを連携する時は

    filepath.Join(dir,"test.txt")

と実装しておくとこの問題が解決します。


* Tips : filepath.Glob()

いつも「あっこれつくったろ！」と一瞬思い、思い出すAPIがあります。

    filepath.Glob(pathRx)

です。

単純に引数に「*.txt」とすると対象を検索してくれるだけなんですけど、重宝します。

golinでも少し使用していて、バージョンリストを作成する際にディレクトリの名前で一覧を作成するわけですが、ダウンロードしてきた値がsrc固定ではない為、「dl@v0.0.0*」で検索しています。

正確には「@*」で検索して新しい方とやるべきかも


* 標準パッケージで解決できない場合

ユーザのディレクトリにSDKをダウンロードした後に、正規の場所に移動する必要があります。ただユーザのディレクトリはWindows以外には環境変数HOMEに入りますが、WindowsはUSERPROFILEに入ります。

そういう時は

    runtime.GOOS

という値にOSを表す文字列が入ります。これをif文で判定するわけです。

    if runtime.GOOS == "windows" {
        home = os.Getenv("USERPROFILE")
    } else {
        home = os.Getenv("HOME")
    }

という感じです。

実際にはPlan9にはHOMEの概念がないらしくPlan9では動作しないかも、、、


* 別の方法(今回の方法

あまりにもこういう条件式が多いと美しくないと思うことがあるかと思います。
そんな時はOS別にファイルを作成します。

golin_windows.go
golin_other.go

というファイルを作って

    // +build windows

もしくは

    // +build !windows

とヘッダ部分に記述します(CSVで複数設定できます)。これはパッケージ名の前に１行あけて記述する必要があります。おそらくdocとの兼ね合いだと思われます。

こうすることでWindowsの時、Windowsじゃない時でビルドされるファイルが変わります。

* 呼び出し側

後は依存しないコード側に

    home := getHome()

と分ける対象の関数を呼び出しをしてあげるだけでOKです。
そうするとビルド環境によってコンパイルを切り替えてくれます。

条件がOSじゃない場合でも例えば

    // +build appengine

としておいて

    go build -tags appengine

と独自のタグを指定することも可能です。
 


* テストを書いてみよう！

* test : test packages

Goはテストも同梱していて

    $ go test .

でテスト実行が可能です。
xxxxx_test.goというsuffixでファイル名で作成し、

    package yyyy_test

    import "tesiting"

    func TestZzzz(t *testing.T) {
    }

TestZzzz()のという名称の関数で引数を*testing.Tにして上げることでテスト対象となります。
※特例としてパッケージ名「yyyy_test」はyyyyパッケージに同居できます。

* Tips : 別パッケージでテスト

私自身privateのテストは行わない主義なのですが、何故かgoのテストについては同じパッケージで書くことが多かったです。多分同一ディレクトリ内に同じパッケージ名の感覚が強いのかもしれません。

今回作成するにあたって（とくにライブラリ）、外部パッケージにした方が、使用方法がわかる。ということに気づきました。同一パッケージでは

    path := GetGoEnv("GOPATH")
    if path == "" {
        t.Errorf("There is no reason why my GOPATH is empty")
    }

というテストになるのですが、別パッケージだと

    path := golin.GetGoEnv("GOPATH")
    if path == "" {
        t.Errorf("There is no reason why my GOPATH is empty")
    }

となって本当に使う時と同じ感じに書けます。

* setup関数的な動作

setup的な処理を行いたい場合はTestMain()を実装します。

    func TestMain(m *testing.M) {
        os.Exit(m.Run())
    }

と書いておくと、通常のテスト動作と同じになります。
fail時にコマンドがエラーを返すようにos.Exit()に戻り値を返してあげます。

今回はテスト時にGOROOTをいじってテストするので一旦作業ディレクトリなどを作成しています。


* 遅いテストをスキップする

今回のコマンドはテスト時にダウンロードしたりもするので、テストがかなり時間がかかります。
2分くらいでは終わりますが、他のテストを追加したい時などはリズムが悪いのでShortモードを利用します。
※ネットワーク遅い場所で10分超えてテストがコケた

時間のかかるテストに対して

    if testing.Short() {
        t.Skip("skipping Download() test in short mode.")
    }

と書いて

    $ go test -short .

と実行するとテストをスキップしてくれます。


* ベンチマーク

Goのテストではベンチマークを取ることができます。
今回は大半の部分はIOの部分が多いので、劇的に早くなってもたかがしてていますが
唯一処理っぽいことをしているバージョン周りのベンチマークを取ってみます！

    func BenchmarkParseVersion(b *testing.B) {
        for i := 0; i < b.N; i++ {
             golin.NewVersion("1.12.1")
        }
    }

prefixにBenchmarkXxxxxを作成し、引数を*tesitng.Bにしてあげます。
ループ値にb.Nを使用することでループ値を勝手に設定してくれます。
※トータル１秒くらいの値でループします

    BenchmarkParseVersion-8          1000000              1029 ns/op

1回のループに1029nsかかっている（実際のコードではNewVersion()を５回やってる）状態です。

* Tips : sort

スライスのソート処理は以前に比べると簡易になりました。

    sort.Slice(target,func(i,j int) int {
        ti,tj := target[i], target[j]
        return target[i] > target[j]
    })

という感じです。
プリミティブな型のスライスのソートは「Ints(),Strings()」などが提供されています。

今回はバージョンの表示の際にディレクトリ名順になっているところに並び替えを行っています。
ここにもベンチマークを入れて測っています。

    BenchmarkSortVersion-8              1000           1726996 ns/op

10000件のソートに1msなのでそこまで遅くもないですね。

* ちゃんと計測する

前処理などを含めてしまうと関数の純粋な処理時間等が図ることができません。
例えばソートの処理は１万件のデータ生成がありますので、その部分は計測しない方が純粋なソート時間を計測できます。(5件で1nsかかっているので、前処理で+2000ns以上かかる計算

なので前処理後に

    b.ResetTimer()

を呼び出して、純粋にソートに対する処理にのみ計測を行うようにしています。


* ベンチマークの処理回数

ベンチマーク自体の回数を指定するには

    $ go test count=1 .

と行うことができます。

処理自体には揺れがあるので、何度か処理を行ってみるのもいいと思います。
またテストが実装のみの変更時にキャッシュで動作してしまう場合があります。

    ok      github.com/shizuokago/golin     (cached)

このような時に明示的にcountを1にして動作させるというハックもあります。


* 標準出力のテスト

標準出力のテストを行うことができます。
Exampleは標準出力のテストで

    func ExampleCreate() {
   
        golin.Create("list")

        // Output:
        // 出力する文字列
    }

とOutputをコメントに書いてテストすることができます。

* Exampleの命名規則

またExampleは後述するドキュメントの要素である為、関数名に細かい命名規則があります。

    Example()
    ExampleF()
    ExampleT()
    ExampleT_M()

とすることでドキュメントとして扱うことができますが、
ドキュメントとしても機能して、名称を替えたい場合は

    Example_suffix()
    ExampleF_suffix()
    ExampleT_suffix()
    ExampleT_M_suffix()

と小文字の_suffixをつけることができます。


* Tips : 標準入力

コマンド作成の時は、標準入力が絡むテストを行う事が多いと思います。
標準入力を行う箇所をio.Readerで利用しておいて、呼び出し側で切り替えられるようにしておくとテストがしやすいです。

    stdin := bytes.Buffer("\n")
    r := golin.Create(stdin) //実際の引数と違います

例えばこうしておくと「何も入力されなかった時のテスト」が可能です。


* ドキュメントを書いてみよう！

* doc : show documentation for package or symbol

doc コマンドはパッケージの仕様を表示するサブコマンドです。
例えば

    go doc sort

とすると、sortのパッケージの仕様が出てきます。
型やなども見るには

    go doc -all sort

とやることができます。
privateも見たい場合は

    go doc -u sort

になります。

パッケージを指定しなかった場合、カレントのパッケージが対象になります。

* 自分のドキュメントを見てみる

パッケージ名を抜くと作業中のパッケージを見ることができます。
パッケージから連続してメソッド名を記述するとメソッドだけを見ることができます。



* 先頭行が大事

ドキュメントを書く場合の最重要ポイントは
英字大文字で開始する。これが大前提になります。

あとシンボルに対して空行があると、そのシンボルのコメントとして認識してくれませんのでくっつけて書きましょう

あと

   /*
    * <- ここ
    */

もドキュメントになるので装飾には注意です。

* BUGS(who) :

これはパッケージの最後にドキュメントに残ります
何か問題があった場合は書いて置くと良いでしょう。

カッコ内に担当者を書くようになっています。


* Tips : mainの場合

コマンドを書く場合はmainパッケージになります。
mainパッケージは特殊で実行ファイルを作る用ですので基本的に「他のパッケージから呼ばれることがない」パッケージになる為、メソッドの記述が出てきません。

どうしても出力したい場合は

    go doc -cmd

としてもOKですが、すべて出したい(詳細な仕様書のようなもの)を出力したい時のような気がするので

    go doc -u -all

としてすべて出力した方がよいでしょう。


* Web表示してみよう！

godoc(先日サポート完了が発表された)コマンドが存在し、内部でサーバを起動することが可能です。

起動するとパッケージのすべてが表示できる状態になります。

    godoc 

とすると、GOPATH内にあるすべてのパッケージのドキュメントを見ることが可能になります。(デフォルトポートは6060)


* ラベルの扱い

BUG():はありましたが、何らかのルールを決めて
これはドキュメントとしては動作はしてませんが、特殊な扱いをすることができます。

例えば

     // TODO(who):

として、

    godoc -notes=".*"

とするとTODOもラベルとして扱ってくれます。

    Deprecated:

が少し特殊でGoLandなどのIDEでサポートしていたりします。(使っている時に動いてびっくりした。

TODOとDeprecatedは標準パッケージにも良く使われています。



* 公開する

ライブラリはgodoc.orgに公開することが可能です。

.link  https://godoc.org/github.com/shizuokago/golin

に公開されます。
GitHubに公開すればというわけではなく、

.link https://go-search.org/ Go-Search

で登録しておく必要があります。
※第三者でも検索したら探して追加してくれる感じ

更新についてはドキュメントの下で即時リフレッシュがあるようですが、一定期間で巡回してくれているらしく、押したことはないです。

* その他のサブコマンド

* bug : start a bug report

何が起こるかわからないので打てないコマンドです。

。。。ではなくて、GitHubのgoのリポジトリのissueページがブラウザで立ち上がります。

* generate : generate Go files by processing source

本日静的解析で @hogedigo が少し話したと思いますが、タグベースで処理を行うことができるものです。


* tool : run specified go tool

基本的にサブコマンドが発表される前にここで実装されていることが多いです。

例えば go fix も細かいオプションを使いたければtoolで

    $ go tool fix

を実行します(実際の呼び出しもcmd/go/internal/base.Tool("fix")って感じで同じ処理を呼んでいます)。go vetなんかもそうですね。


