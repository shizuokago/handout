コマンドを作ってみては？
Shizuoka.go Vol.13
30 Mar 2019
Tags:golang

secondarykey
Programmer
https://github.com/secondarykey/
@secondarykey

* Tourを終えた人へ

Tour of Go をやり終えて簡単な言語仕様は把握したところでコマンドでも作ってみれはどうかな？という提案めいた発表です。

Go は簡単にHTTPサーバを立てたりもできますが、さまざまなプラットフォームでの動作もできるGoでコマンドを作ってみたいと思います。コマンドを作りながらGoでソフトを作る時のTipsやGoのサブコマンドの使い方などでGoの魅力を紹介できたらなぁと思います。

なんか書き足して行ったら、かなりのページ数になりました。
何か作ったことのある人でも３回位へぇって言える箇所があればなぁと思います。


* あんなことこんなこと

少しいままで作ってきたものを紹介したいと思います。
私の場合は仕事ではなく、仕事上でのツールを作ることが多く、Goはすごく重宝しています。

あまりにもメンテナンスをしていなくて、ほぼ死んでるのでメンテしてかないと。。。と思いながら開いて「わぁ」ってなって閉じていることが多いです。

Goではいろんなことができるのが伝われば幸いです。


* github.com/shizuokago/blog

GAE/Goのブログエンジン

GopherJSでエディタを作成していてちょっと最近触ろうと思ったんだけど、GopherJSどころかjQuery依存していて、移行できるか心配。

GopherJSはGo言語でJavaScriptを動作させる仕組みで、開発当初はかなりのキワモノだと思っていましたが、現在もメンテナンスをされており、いろんな場所で活躍しているみたいです。



* github.com/secondarykey/speaks

Simple SNS

閉ざされたネットワーク上のレガシーな現場で
チャットシステムを導入するべく作ったチャットシステム

HTTPだけではなくWebSocketも気軽にサーバを立ち上げることが可能です。

先日、jQueryを排除してMDL化しました。ActiveDirectoryアクセスを可能にしてより簡単に導入できるようにしています。

ただ冷静に考えたらgRPC化をしたほうがかっちょええってことに気付いて現在設計中。


* github.com/shizuokago/gopredit

GAE/GoでGoのpresentionツールをサービス化してみたものです。
先日動かしてみたら見事に動きませんでした。かなり初期に作ったのでソース見たらボロボロでした。(panicの連発

テストフレームワークも使っていて、なにやらボロボロです。

現在この資料も含めて管理方法を模索中でして、簡単にプレゼンをまとめれたらなぁと思っています。


* github.com/secondarykey/dizzy

先程説明のあった静的解析を行ってDatastoreに簡易的にアクセスする為に作成したもの。ちょうど作っている時にmerucariのDatastoreのライブラリが出てうーんと思ったけど一応作り込んだもの。

ちょうど実装中に少し大きなものを作成開始してしまい、それに適用しなかった為、実運用をのがした悲しいツール

内部でtestを自動実行する仕組みを持っていて、それをツール化して抜き出したい。


* github.com/secondarykey/davgo

WebDAVアクセスを行った時に使ったもの。
久しぶりに見たら案外コードが書いてあって、全部自分でコーディングしたのか怪しい。(サンプル持ってきただけ？

某社の某ストレージサービスへのAPI公開時に作ったもの。ﾁﾗﾁﾗ

* github.com/secondarykey/yuru

某パズルゲームの計算アルゴリズムを作成しました。
アルゴリズムの勉強用ではあったのですが、チューニング等の勉強をした記憶もある

* github.com/ikascrew/ikascrew

いわずとしれたVJ イカスクリューを支えるVJ System。

opencvを利用した動画表示、切替を行う仕組みであり、Shinyによる表示などができないか？などを作成してみたりしたこともある。

最近VJをやってないので少し放置気味ですが、go-opencvからgocvに変更は行っています。


* github.com/ikascrew/xbox

USBのゲームコントローラーのイベントを拾うライブラリ。

動画操作の為に作成したものではあるが、実はこのコード(ライブラリを使いやすくしただけですが)を書いた後にアメリカ海軍がXBOXのコントローラーを採用しました。

製造業の現場などで使われる可能性も視野に入れていいかもなぁなんて思ってます。

実はオリジナルでトグルを作成し、ボリュームコントローラーなどを自作しようかな？などと思っています。


* その他

FTPベースでファイルを同期するmysyncというものも存在するのですが、それはとある世界線にしか存在しません。

その仕組みを使っているシステムは、開発環境自体の仕組みが特殊で特有の同期を行います。



* さぁはじめましょう！

* 今回つくるもの

.link https://twitter.com/golang/status/1106303553474301955 Goのアカウント

Gopherは @golang がリリースをつぶやくと
おもむろにGoをダウンロードしてGOROOTを切り替えるという習慣があります。
Gopherしぐさの１つです。

いやいやDockerでやれよ！という声が聞こえないこともないですが無視しておきます。

とにかくこの作業を簡単にするコマンドを作ろうと思い立ちました。

* コマンド名は「golin」

オリンピックを来年に控えていますのでこの名前にしました！
名称にGoをつけてしまうのもGopherしぐさの１つです。

1. GOROOTを確認
2. 指定されたバージョンのGoを準備
3. currentというシンボリックリンクを作成

という動作になります。

それでは実際に作成して行きましょう！
※資料では作るところは説明していきませんが、
 このコマンドを作っていく上で気付いたことを書いていった資料です。

* help : go <command> [arguments]

まずはgoのhelpを見てみます。

    $ go help
          bug         start a bug report
          build       compile packages and dependencies
          clean       remove object files and cached files
          doc         show documentation for package or symbol
          env         print Go environment information
          ...     

ヘルプを打つとサブコマンドにどういったものがあるかがわかります。

それぞれのサブコマンドにもhelpがあり、gopathのようなサブコマンドにはない他の引数などもあります。


* version : print Go version

次はバージョンの確認です。

    $ go version
    go version go1.12 linux/amd64


現在のGoのバージョンをプリントてくれます。そのGoのビルドOSなどもわかります。

基本的にはGo1.12における話をしていきますが、このコマンドの性質上、実際のテスト中にGoのバージョンが古くなったりして困ったこともありました。
※例えば初期実装ではstrings.SplitAll()を利用していたけど、バージョンが古くなるとメソッドがなくて、コンパイルエラーが発生してしまう

* デモ

実際にどのようになるか見てみましょう！

まずはコマンドを作成します。

* get : download and install packages and dependencies

ライブラリを使用したり、 コマンドを持ってきたりする時に使います

    $ go get http://golang.org/shizuokago/golin/cmd/golin

今回はコマンドを別ディレクトリにしているので名称が長いですが、
ライブラリを持ってくる時は

    $ go get http://golang.org/shizuokago/golin/

だけでOKです。

Go1.11から導入されたModulesの説明を後に入れている為、詳細はここでは省きます。


* install : compile and install packages and dependencies

install は$GOPATH/binにコマンドとして展開してくれます
$GOPATHに設定がない場合、$GOBINが必要になります。

普段のGopherはGOPATHが存在する人が多いのでGOPATH/binになる方が多いと思います。

GOPATHがない状態で、GOBINを設定する人自体が少ないかもです。
※私は最近はGOPATHを設定しない人なので、その人になります

* コマンドを実行してみる

    $ golin list

これでダウンロードできるリストが表示されます。

    $ sudo golin 1.12.1

実行には管理者権限(ディレクトリのsymblic linkを作成している為)が必要です。
再度バージョンを見てみましょう！

Windows(コマンドプロンプトを管理者権限にして)でも実行できます！
※Macでも試しています。

まぁここに少しバグ？問題があるのですが、、、

* 使ってみる

今回の勉強会の為にgolinはライブラリとしても何個かAPIを公開しています。
ライブラリとしての使い方も見ていきましょう！

* Let's Go!

* golinをライブラリとして使う

一旦demo.goを作成してみます。

.code demo.go

※Create()は権限もいるので他のメソッドが良いでしょう。

* fmt : gofmt (reformat) package sources

書いたらfmtです。

    $ go fmt *.go

ソースをフォーマットしてくれます。
チーム開発時に戦争にならないのはとても良いと思います。
頑張ってきれいに整形してfmtで戻されるなんてこともあります。

おそらくIDE,エディタに保存時に動作するように埋め込んでおくのが吉かと思います。

* vet : report likely mistakes in packages

ソースの簡単な問題を発見してくれます。

* fix : update packages to use new APIs

なんぞ？

* run : compile and run Go program

実際に動作させてみます。

    $ go run demo.go

同一階層(パッケージ内)でファイルが多くなった場合は

    $ go run .

とするとその階層の実行をしてくれます。(テストも排除してくれます)
※Go1.11からこの指定ができるようになりました。


* clean : remove object files and cached files

コンパイル時に作成されるオブジェクトをクリーンしてくれます。
例えばcgoを呼び出したりしているとこれらを作成してキャッシュで使われることが多いです。

cacheはGOPATH/pkgに存在します


* build : compile packages and dependencies

    $ go build demo.go

実行ファイルを作成します。

    $ go build -o demo .

実行単位が大きくなった場合は出力ファイルを指定しておかないとディレクトリ名がファイル名になってしまいます。

Windowsで実行するとexeが付きます。

* 実は。。。

さらっと実行を行いましたが、Goで大きく変更されている部分があります。
以前は実装に外部パッケージを利用した場合、

    demo.go:5:8: cannot find package "github.com/shizuokago/golin" in any of:

が発生していました。ないので当然ですね。
※今回は最初にデモやっているので、パッケージのソースがある状態になってますが、、、

現状のGoではこのようなことは起こりません（当然パッケージがないと起こります）

* Go Modules(基本編)

* Goの依存関係解決の道

Go 1.11から登場したGo Modulesはパッケージの依存関係を解決するGoの機構です。
Goの依存関係解決は、

  make
  godep
  dep
  Go Modules(vgo) <- Now!

という感じで進化してきました。
※なんか抜けてるか？
Go1.11から本家でのサポートになりました。
godep時代にそろそろ真面目に、、、って思った次のタイミングでdepの話が出てからおざなりになってしまった。。。


* GO111MODULE

GO111MODULEはこの動作のための環境変数です。
現在(1.12)はまだ正式リリースではなく、移行段階に入っている状態です。

   1.11 -> off
   1.12 -> auto
   1.13 -> on

とデフォルトではなる予定(現状はauto)です。
Go1.11のonとGo1.12のonにも違いがあるので注意が必要です。
※GOPATH以外での実行が不可

* GOPATH mode(GO111MODILE=off)

おそらく古いブログ、メンテされてないライブラリなどはインストール方法などはこのモードで書かれていたりしますので、その通りにやると動かない状態などが出てくるかもしれません。
まぁちゃんとしたリポジトリはすでにdep化なども行っていて、すでにModulesに移行できていることが多いと思います。

単一のGOPATHで管理していると、別のプロジェクトから違うバージョンを使いたい場合に問題が起こっていました。その為、プロジェクト内でGOPATHを指定したり、vendorなどを利用して管理していました。

* Tips : GOPATH

環境変数GOPATHがないと動かない。みたいな文献もありますが、現状のバージョン1.8では環境変数GOPATHがない状態では、ユーザのディレクトリにgoというディレクトリを作成し、そこをGOPATHとみなす動作をします。

GolinもGOPATHを見る必要がある為、考慮して動作しています。

* Hybrid Mode(GO111MODULE=auto)

現状1.12は指定がない場合、このモードで動作します。
GOPATH配下での動作はon、それ以外はoffで動作します。

なんか気持ち悪いのでデフォルトよりはonにしておくのがよいと思います。

* Go Module(GO111MODULE=on)

Go1.13からはこのモードで動作します。 今後GOPATH/srcは使用しなくなります。 
今日は少なくともModuleの基礎だけは覚えていっていただければな。と思います。

* Modulesの動作

Go Modulesは関連が必要になった時に動作する為

    go run
    go build
    go test
    go get
  
を行うと動作します。

* go.mod

GoModulesで自動的に作成されるgo.modファイルの中身です。

    module github.com/shizuokago/handout
    
    go 1.12
    
    require github.com/shizuokago/golin v1.0.0 // indirect 

対象のモジュール名と、使用しているGoのバージョン、使用しているパッケージが表示されます。

* list : list packages or modules

パッケージの一覧を表示するコマンドになります。

    go list -m all

そのモジュールが使用しているパッケージの一覧を表示してくれます。(-mは1.12.1から

    go list all

も使えるのです、、、、これはパッケージの一覧が出るだけです。


* Go Modules(利用編)

* バージョン依存

GOPATHモードで１つのディレクトリで管理していると、別のプロジェクトが同じライブラリを使う場合に新しいバージョンに更新してしまう為、自分だけのバージョンを保持することができません。

そのため自分の手元でローカルで管理している場合が多くありました。

golinは一部をライブラリとして公開していますので、バージョンによる挙動の変化を起こして見ましょう。

* バージョンの付け方

ライブラリ作成側の観点になりますが、提供している側はタグを打つことで、バージョンによる提供を行うことができます。 

.link https://semver.org/ semantic versioning

gitに[vX.X.X]というタグを作ることでバージョンを指定して呼び出すことも可能です。呼び出してみましょう！

  go get -u github.com/shizuokago/golin@v0.8.0

とすることでv0.8.0を使用するよ。と宣言できます。
go.mod内を見てみるとv0.8.0を使用するような変更が加わります。

    goli@v1.0.0
    goli@v0.8.0+incompatible


* 実際の管理場所

GoModulesにより単一のGOPATH上で管理できるようになります。
GOPATH/pkg/modを見てみましょう。

GOPATHMode時と同じ管理っぽく見えますが、最後のモジュール部分で
GOPATH/pkg/mod/github.com/shizuokago内に


という感じで表示されるはずです。
タグが存在しない場合はv0.0.0 - コミットハッシュとなります。


* ハッシュ値での指定

コミットのバージョンでも指定可能になっています。
hgではわかりませんが


* mod : module maintenance

    go mod tidy 

で無駄な関連性があるものを削除してくれます。

   go clean -cache 

でキャッシュは削除可能です。


* ローカルパッケージを使うパターン

自分だけのパッケージを使いたい時です。





* Tips : ソースの配置方法

ライブラリを作成する場合、パッケージルートが望ましいです。
例えば(私がそうなのですが) src下にソースを置きたい人なんですが、
ライブラリとして取得する場合に

    go get github.com/xxxx/yyyy/src

とまぁカッコ悪い感じになってしまうのです。
ちょっと後でパッケージの話もあるので詳細はそこで話していきましょう。

* Tips : ログを残そう！

Goにはlogパッケージが存在し、ログを残せるようにはなっています。低レベルのものしか基本的には提供してないので、便利なライブラリを探そうとしちゃいそうですが、ライブラリを書く場合はそれらは使わない方が良いと私は考えています。

どっかで誰かが言ってました。

「ユーザはあなたのライブラリを使いたいのであって、あなたのログライブラリを使いたいわけではない」

うんいい言葉です。

・・・とはいえ、覇権に一番違いのはglogだと思います。




* コードを見てみよう！

* ダウンロードする仕組み

Goをダウンロードしている仕組みはつぶやきにもあったように

    $ go get golang.org/dl/go1.12.1

と行うと「go1.12.1」という実行ファイルがインストールされます。
このファイルを実行するとユーザのディレクトリ配下にsdk/go1.12.1を作成し、そこにgoのSDKが一式ダウンロードされる仕組みになっています。

ここで「GOPATH/bin」の値をみたいところですが、先述したとおり、GOPATHは設定されてないユーザもいるので、環境変数値から値をとることはできません。


* env : print Go environment information

そんな時の為にenvというサブコマンドがあります。
パスが欲しい場合は

    $ go env GOPATH

が確実に取得することが可能です。

またこのコマンドは

    $ go env

で一覧を取得したり、-jsonでjsonで取得したりもできます。


* みなさんはご存知ですか？

ディレクトリのシンボリックリンク作成コマンドは

Windowsは

    # mklink /D current go1.12

Linux(UNIX系)のシンボリックリンク作成コマンド

    # ln -sd go1.12 current

という風になってます。

これらを使い分けを


* そんな時は！！！

osパッケージが吸収してくれることがあります。（いやきっと解決してくれます

例えばこの場合は、

   os.Symlink("go1.12","current")

と行うと２つの違いを吸収してくれます。

   os.Rename(old,new) : linux mv, windows move

なんかも差分を吸収してくれます。

今回知りましたが、コマンドを直接打った場合、Windowsのrmdir,moveはPATH上には存在しないので、コマンドとして打てないようです。


* 他の代表的な例

ファイルパスを扱う場合は

    path/filepath

を利用して、[\]と[/]の問題を解消してくれます。
ファイルパスを連携する時は

    filepath.Join(dir,"test.txt")

と実装しておくとこの問題が解決します。


* Tips : filepath.Glob()

いつも「あっこれつくったろ！」と一瞬思い、思い出すAPIがあります。

    filepath.Glob(pathRx)

です。

単純に引数に「*.txt」とすると対象を検索してくれるだけなんですけど、重宝します。

golinでも少し使用していて、バージョンリストを作成する際にディレクトリの名前で一覧を作成するわけですが、ダウンロードしてきた値がsrc固定ではない為、「dl@v0.0.0*」で検索しています。

正確には「@*」で検索して新しい方とやるべきかも


* 標準パッケージで解決できない場合

ユーザのディレクトリにSDKをダウンロードした後に、正規の場所に移動する必要があります。ただユーザのディレクトリはWindows以外には環境変数HOMEに入りますが、WindowsはUSERPROFILEに入ります。

そういう時は

    runtime.GOOS

という値にOSを表す文字列が入ります。これをif文で判定するわけです。

    if runtime.GOOS == "windows" {
        home = os.Getenv("USERPROFILE")
    } else {
        home = os.Getenv("HOME")
    }

という感じです。

実際にはPlan9にはHOMEの概念がないらしくPlan9では動作しないかも、、、


* 別の方法(今回の方法

あまりにもこういう条件式が多いと美しくないと思うことがあるかと思います。
そんな時はOS別にファイルを作成します。

golin_windows.go
golin_other.go

というファイルを作って

    // +build windows

もしくは

    // +build !windows

とヘッダ部分に記述します(CSVで複数設定できます)。これはパッケージ名の前に１行あけて記述する必要があります。おそらくdocとの兼ね合いだと思われます。

こうすることでWindowsの時、Windowsじゃない時でビルドされるファイルが変わります。

* 呼び出し側

後は依存しないコード側に

    home := getHome()

と分ける対象の関数を呼び出しをしてあげるだけでOKです。
そうするとビルド環境によってコンパイルを切り替えてくれます。

条件がOSじゃない場合でも例えば

    // +build appengine

としておいて

    go build -tags appengine

と独自のタグを指定することも可能です。
 


* テストを書いてみよう！

* test : test packages

Go の醍醐味の1つであるtestです。
醍醐味というのは言語レベルでサポートしているってことです。


* testの基本

xxxxx_test.goというファイル名で作成し、

    package yyyy_test

    import "tesiting"

    func TestZzzz(t *testing.T) {
    }

と書いていきます。

今回パッケージをyyyy_testとしています。

Goは同一ディレクトリ内には同一パッケージが基本使用ですが、yyyy_testはパッケージとして同居できる仕様があります。

私自身privateのテストは行わない主義なのですが、何故かgoのテストについては同じパッケージで書くことが多かったです。多分同一ディレクトリ内に同じパッケージ名の感覚が強いのかもしれません。

* テストの方式

かなり以前はassert系の議論が活発でしたが、現状もみんなが使っている。というようなテストフレームワークは存在しません。

これは

1. Go単独でテストが可能である。
2. いちいち書いていった方が仕様がわかる

という理論でみんな納得したという敬意があります。


* Tips : 別パッケージでテスト

今回作成するにあたって（とくにライブラリ）、外部パッケージにした方が、使用方法がわかる。ということに気づきました。

    path := GetGoEnv("GOPATH")
    if path == "" {
        t.Errorf("There is no reason why my GOPATH is empty")
    }

より

    path := golin.GetGoEnv("GOPATH")
    if path == "" {
        t.Errorf("There is no reason why my GOPATH is empty")
    }

となる感じ


* Bench

ベンチマークを取ることができます。

今回は大半の部分はIOの部分が多いので、



* Tips : sort

スライスのソート処理は以前に比べると簡易になりました。

    sort.Slice(target,func(i,j int) int {
        ti,tj := target[i], target[j]
        return target[i] > target[j]
    })

という感じです。
プリミティブな型のスライスのソートは「Ints(),Strings()」などが提供されています。



* Example

標準出力のテストです。

Exampleは標準出力のテストで


* Tips : Example is Document

後述しますが、Exampleは出力のテストでもありますが、ドキュメントとしてもリンクしてくれるスグレモノです。

使用方法などを記述したい場合はExampleを利用しておくと良いでしょう。（その場合outputはない(から文字)テストになります。



* Tips : 標準入力

コマンド作成の時は、標準入力が絡むテストを行う事が多いと思います。
標準入力を行う箇所をio.Readerで利用しておいて、呼び出し側で切り替えられるようにしておくとテストがしやすいです。





* ドキュメントを書いてみよう！

* doc : show documentation for package or symbol

doc コマンドはパッケージの仕様を表示するサブコマンドです。
例えば

    go doc sort

とすると、sortのパッケージの仕様が出てきます。
型やなども見るには

    go doc -all sort

とやることができます。
privateも見たい場合は

    go doc -u sort

になります。

パッケージを指定しなかった場合、カレントのパッケージが対象になります。

* 自分のドキュメントを見てみる

パッケージ名を抜くと作業中のパッケージを見ることができます。
パッケージから連続してメソッド名を記述するとメソッドだけを見ることができます。



* 先頭行が大事

ドキュメントを書く場合の最重要ポイントは
英字大文字で開始する。これが大前提になります。

あとシンボルに対して空行があると、そのシンボルのコメントとして認識してくれませんのでくっつけて書きましょう

あと

   /*
    * <- ここ
    */

もドキュメントになるので装飾には注意です。

* BUGS(who) :

これはパッケージの最後にドキュメントに残ります
何か問題があった場合は書いて置くと良いでしょう。

カッコ内に担当者を書くようになっています。


* Tips : mainの場合

コマンドを書く場合はmainパッケージになります。
mainパッケージは特殊で実行ファイルを作る用ですので基本的に「他のパッケージから呼ばれることがない」パッケージになる為、メソッドの記述が出てきません。

どうしても出力したい場合は

    go doc -cmd

としてもOKですが、すべて出したい(詳細な仕様書のようなもの)を出力したい時のような気がするので

    go doc -u -all

としてすべて出力した方がよいでしょう。


* Web表示してみよう！

godoc(先日サポート完了が発表された)コマンドが存在し、内部でサーバを起動することが可能です。

起動するとパッケージのすべてが表示できる状態になります。

    godoc 

とすると、GOPATH内にあるすべてのパッケージのドキュメントを見ることが可能になります。(デフォルトポートは6060)


* ラベルの扱い

BUG():はありましたが、何らかのルールを決めて
これはドキュメントとしては動作はしてませんが、特殊な扱いをすることができます。

例えば

     // TODO(who):

として、

    godoc -notes=".*"

とするとTODOもラベルとして扱ってくれます。

    Deprecated:

が少し特殊でGoLandなどのIDEでサポートしていたりします。(使っている時に動いてびっくりした。

TODOとDeprecatedは標準パッケージにも良く使われています。



* 公開する

ライブラリはgodoc.orgに公開することが可能です。

.link  https://godoc.org/github.com/shizuokago/golin

に公開されます。
GitHubに公開すればというわけではなく、

.link https://go-search.org/ Go-Search

で登録しておく必要があります。

更新についてはドキュメントの下で即時リフレッシュがあるようですが、一定期間で巡回してくれているらしく、押したことはないです。

* その他のサブコマンド

* bug : start a bug report

何が起こるかわからないので打てないコマンドです。

。。。ではなくて、GitHubのgoのリポジトリのissueページがブラウザで立ち上がります。

* generate : generate Go files by processing source

本日静的解析で @hogedigo が少し話したと思いますが、タグベースで処理を行うことができるものです。


* tool : run specified go tool

基本的にサブコマンドが発表される前にここで実装されていることが多いです。

tool で行うと細かい設定ができたりもします。


* golinの注意点

GOPATHが固定値ではなくなってしまう為、パスを検索する必要がある

あーGO111MODULEの状態で検索するパスを変更しないとあかん

