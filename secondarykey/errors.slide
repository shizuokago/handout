errorのお話
Shizuoka.go Vol.14
20 Jul 2019
Tags:golang

secondarykey
Programmer
https://github.com/secondarykey/
@secondarykey

* 例外なしのGo言語

Go言語には例外がありません。
他の言語とは異なるアプローチを取っているとドキュメントにも書いてあります。

.link https://golang.org/doc/faq#exceptions Why does Go not have exceptions?

どこでだったか、簡単な平行処理を実現する為に例外を使用しないことを決めたと誰かが言っていたような、、、

channel のエラーについてはこの後hogedigoの発表であるかと思います。

* そこでerrorを利用

「必ず」ではないのですが、関数の戻り値が複数可能であることを利用して、
関数の最後にerrorを付ける習わしになっています。

e.g)

    func Something() (*Some,error) {
        if x {
            return nil,fmt.Errorf("something error!")
        }
        return s,nil
    }

* Ex: tryというアプローチ

つい先日まで「try」というアプローチが話されていました。
Go1.14で追加される予定だったんおで話そうと思っていましたが、
今週中ごろにアプローチを断念するという発表がありました。

.link https://github.com/golang/go/issues/32437 

いわゆる

  if err != nil {
  }

をいかにして少なくするか？という問題の解決方法ですが、
個人的にはerrorを書くことでプログラムの動作が単純になるというか、そんなに苦となる場面はないです。
※よく訓練されているだけ

今回のerrorの話もそうですが、Go2へ向けて様々なアプローチを行っている段階なので追いかけてみるのも良いでしょう。


* 今回はtryの話ではなくー

途中で注記もありますが、Go1.13に改良されるerrorsの話になります。

簡単なコードを交えてどのようになるのか？
この辺りを覚えていっていただければと思います。

* errorとは

    type error interface {
        Error() string
    }

という簡単なインターフェースです。
Goは「関数持ってたらインターフェースやで」なので

    func (o Org) Error() string {
         return "MojiMoji"
    }

とするだけでerrorになることが可能です。


* errorsパッケージ

標準パッケージにerrorsというパッケージが存在します。

.link https://godoc.org/errors errors-GoDoc

errros.New(string)を持っておりエラーを生成します。

* errors.New()の扱い

パッケージ内のエラー値にしている実装が多いです。

    var (
        ErrInvalid    = errors.New("invalid argument")
        ErrPermission = errors.New("permission denied")
        ErrExist      = errors.New("file already exists")
        ErrNotExist   = errors.New("file does not exist")
        ErrClosed     = errors.New("file already closed")
        ErrNoDeadline = poll.ErrNoDeadline
    )

.caption os/error.go

様々なライブラリの実装でこのように扱われていることが多いです。

* Ex: New()の実体

別に気にしたこともなかったのですが、
せっかくなのでerrors.New()の実体を見てみることにしました。
※標準パッケージは思わぬ処理をやってたりするので覗いてみると案外面白いです

    func New(text string) error {
        return &errorString{text}
    }
    type errorString struct {
        s string
    }
    func (e *errorString) Error() string {
        return e.s
    }

.caption errors/errors.go

少し想像はしていましたが、コメントありで20行のコードでした、、、

* 実際のコードを交えて 

実際にどう困るのか単純な実装を見てみましょう。

構造が深くなっていくにつれて、どんどん問題が深刻化していくという話です。
まずは単純なプログラムを書いてみます。

仕様としてはコマンドで渡されたファイルの中身に
trueという文字列が入っている場合、trueそれ以外はfalseという処理を書きます

* 関数側

.code example-1.go /ISFUNCTION START/,/ISFUNCTION END/

* 使用側

.code example-1.go /USE IS FUNCTION START/,/USE IS FUNCTION END/

* 実行してみます。

    $ go run example-1.go true.txt false.txt

と実行すると

    true.txt is true
    false.txt is false

と出力されるプログラムです。

* ファイルが存在しない場合

    $ go run example-1.go noexists false.txt

と実行すると

    open noexists: The system cannot find the file specified.
    false.txt is false

と出してくれます。

* エラーを増やしてみる 

falseを判定するときに
falseが入ってない場合はerrorとして返すようにしてみましょう。

* エラーの生成

エラーを発生させる場合、errors.New()より使われるのが

    fmt.Errorf() error

※内部はerrors.New()をfmt.Sprintf()を使って呼び出しているだけです。

なので仕様変更部分は

    if strings.Index(v,"false") != -1 {
        return false,nil
    }

    return false, fmt.Errorf("neither true nor false")

って感じですかね？


* 実行してみる

    $ go run example-2.go true.txt other.txt

other と書かれたファイルを渡してみます。

    true.txt is true
    neither true nor false

このようになります。


* Ex: errorの文字列は小文字にする

errorの文字列は小文字にすることが推奨されています。

その文字列がどう使われるかわからないからって理由だったと思いますが、
どこに書いてあったか、、、
まぁプロジェクトのルールによると思いますが。

※私の勘違いかもしれません、、、


* エラーの判定

「ファイルがない時は途中でも処理を終わらせたい」というような変更をかけます。

このような時に返ってきたerrorを判定する必要が出てきます。


* やってはいけない

一番やってはいけないと言われているのは文字列による処理です。

    if err.Error() == "neither true nor false" {
    }

相手が文字列を変更するだけでエラーをハンドリングできなくなります。

* エラーを固定にして回避

  var NeitherErr = errors.New("neither true nor false")

というエラーを作って

  return nil,NeitherErr

として返してポインタとして

  if err != NeitherErr {
      os.Exit(1)
  }

で判定を行うことも可能です。
※前述の標準パッケージが利用している方法

* これだといろいろと問題が、、、

- エラーに処理した文字列を入れたい

となった場合、ただのパッケージ変数であるNeitherErrでは文字列を入れることができません。

まぁポインタが一緒で、文字列を変更するのも可能ではありますが、複数からの呼び出しには対応できません。

* オリジナルのエラー型を作成

型を作成してみます。

    type NeitherError string

    func NewNeitherError(v string) error {
        e := NeitherError(v) 
        return &e
    }

    func (n NeitherErorr) Error() {
        return string(n)
    }

example-4.goに記述

* 判定側は

キャストを行って判定します。

    if _, ok := err.(*NeitherError); !ok {
        os.Exit(1)
    }

条件は型が逆なので!okになってます。

* 注意: errorで返すこと

昔とあるライブラリで苦労したお話です。
オリジナルエラーを実装するときに

    func Do() *OriginalError {
    }

と実装されていて、別段問題はないように見えますが
利用する側はerr変数の型が最初の呼び出しだったら*OriginalErrorになり、
そのerr変数を別の関数で使いまわせなくなります。

それだけではなく、nil判定がうまく動作せず、副作用が起こる場合があります。
errorで返してしまうとnilだけど型情報を持っていると判断され純粋にnil判定できません。
.caption effect.goを参照

そうしなければならないシチュエーションがあるのかもしれませんが、
２度目の呼び出しなどでerror型には入るので実装としても気持ち悪くなります。

* Ex: panic()

処理を終了すると決まっているのであれば、panicが案外優秀です。
スタックトレースも出ますし、処理も止まります。
簡易的なプログラムならそれでもいいかもと思います。

とはいえ人が使うライブラリやらフレームワークでは絶対無理ですし、
Webサーバのような処理でプロセスを殺すことになりますので、やってはいけません。

※案外優秀と言っていますがpanic()は再帰処理からの復帰以外では容易に使っては行けないという暗黙のルールがあります。


* インターフェース的なアプローチ

netパッケージにはnet.Errorがあります。

.link https://golang.org/pkg/net/#Error net package Error

このインターフェースは
 
     Timeout() bool
     Temporary() bool

を持っていて、Temporary()がtrueのときはリトライをする実装を行うことを想定しています。

* これを利用する

これを利用？して

    type temporary interface {
        Temporary() bool
    }

と実装し、

    if _, ok := err.(*temporary); ok {
        //retry
    }

と行うという手段があります。
※errorかどうかの判定を入れてもいいかも

errorの型ではなく振る舞いで処理するイメージです。

* 結局のところ

このサンプルの処理は簡単に書いていますが、
実際のコードになると、その関数は複数の箇所から呼び出され、最終的な深さはわかりません。

exampleをあえて複雑にしてみます。

.caption example-5.go

このコードは仕様変更がないです。

* 存在しない場合、ファイルを作成

os.Open() の時に失敗したエラーの場合に、
ファイルを作成する処理を入れて見ることにします。

すると問題が表面化します。

.caption example-6.go

実行するとわかりますが判定ができません。

* どのように解決するか？

処理が深くなるにつれ、どんどん付加情報を追加したい場合が多く、
このようになることが多くなると思います。

Gopher達はerrorを伝達できる仕組みを持った
オリジナルのラッパーをみんな個々で作成し、なんとか耐えしのいできました。

* github.com/pkg/errors

そんなときGoCon spring 2016のキーノートでの発表がありました。

.link https://dave.cheney.net/paste/gocon-spring-2016.pdf gocon-spring-2016

ラップが可能なおそらく一番使われているerrors系パッケージ

    "github.com/pkg/errors"

error系の文献をいろいろあさっていて説明なしに
pkg/errorsを当然に使用しているのがあったので自然に浸透していて注意が必要かもです。

* そして1.13での移行

今回の話をするきっかけになったのは
これらを1.13で正式にerrorsでサポートすることになった為です。

現在は移行の為に

   "golang.org/x/xerrors"

が生まれています。

ライブラリ等はランタイムのサポート状況にもよりますが、
一旦はxerrorsで実装をかけて、1.12移行をサポートしないと決定した段階で、
これ以降の実装に切り替わっていくと思います。

* 注：ここからのコードは1.13です。

現在は1.12ですので、ここからの実装は動作しません。
サンプルの動作はtipを利用しています。

.link https://tip.golang.org/pkg/errors/ tipのエラードキュメント

* Ex: 最新のビルド

今回ビルドしたのもそうですが、
最新のビルド状況をみたい場合はgotipと呼ばれる状態から取得することが可能です。

    $ go get golang.org/dl/gotip

とするとbinにgotipができますので

    $ gotip download

として、最新のgoがビルドされます。

.link https://tip.golang.org/ tipのサイト

.link https://tip.golang.org/pkg/errors/ tipによる1.13のerrors


* ": %w"

前述の問題であった対処方法として": %w"とするとWrapになります。

    return fmt.Errorf(": %w",err)

としてエラー処理を行うとそのエラーはラップしたエラーになります。
スペースがないと駄目です。

pkgだとすると errors.Wrap(err,"message") と同等です。

* Unwrap()

    Unwrap(err error) error

そのエラーを取り出すことができます。
pkgだとすると errors.Cause(err) と同等です。


* As()

    As(err error,target interface{}) bool

型による判定は errors.As() として実装します。
pkgのCause()は必要なくなります。

* Is()

    Is(err,target error) bool

値を比較していた部分をIsに変更します。
pkgのCause()は必要なくなります。


* 新しいerrorへ

今後ライブラリがラップしたエラーを返す場合もあると思いますので注意が必要ですね。

.caption example-errors.go

* and more...

さて、なんか色々できる感じになっていますが、実は新エラーの最大の利点を書いていません。

    go version devel +f518a96 Fri Jul 19 20:08:48 2019 +0000 linux/amd64

を利用していましたが、ちょっとまだ動作しないようなのでxerrorsに差し替えて実行してみます。

* "%+v"

%vとしていた部分を変更し実行してみましょう！

    $ go run example-xerrors.go notexist

* Go1.13のお話

Go Modulesが正式にリリース、errorの仕様追加、
Illumosサポートとわかりやすいところだけで盛りだくさんですが、呑みながら何かを話すと思います。

.link https://shizuoka-go.connpass.com/event/140162/ 8/22 Go1.13 Release Party in Shizuoka

おっさんと飲むだけですが、是非参加いただければと思います。
