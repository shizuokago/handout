errorsのお話＋log
Shizuoka.go Vol.14
20 Jul 2019
Tags:golang

secondarykey
Programmer
https://github.com/secondarykey/
@secondarykey

* error

* 例外なしのGo言語

Go言語には例外がありません。
よく揶揄されることが多いですし、
実際のコードのエラー処理は

簡単な平行処理を実現する為に例外を捨てた。とも言われています。


* そこでerrorを利用

「必ず」ではないのですが、関数の戻り値が複数可能であることを利用して、
関数の最後にerrorを付ける習わしになっています。


* e.g)

    func main() {
        s,err := Something()
        if err != nil {
            fmt.Fatal("%v",err)
        }
        //sを利用した処理
    } 

    func Something() (*Some,error) {
        if false {
            return nil,fmt.Errorf("something error!")
        }
        return s,nil
    }

* Ex: tryというアプローチ

err地獄と称されるこの問題について先日まで「try」というアプローチが話されていました。
Go1.14で追加される予定だったんおで話そうと思っていましたが、
今週中ごろにアプローチを断念するという発表がありました。


* 実装してみて実際に思うこと

例外機構がない場合、紳士にコードと向き合うことが多く、
個人的には「地獄」とまでは思っていないです。

tryの話の時も正直しっくりは来てなかったのですが、
特に否定できるほどの根拠もなかったので特に反対もしてません。

* エラー地獄の話ではない

今日はエラー地獄の話ではなく、正しくエラー地獄と向き合うという話です。
途中で注記もありますが、Go1.13に導入される話になります。


* Let's Go!

* 実際にどうなるか見てみましょう。

構造が深くなっていくにつれて、どんどん問題が深刻化していくという話です。
単純なプログラムを書いてみます。

コマンドで渡されたファイルの中身にtrueという文字列が入っている場合、true
それ以外はfalseという処理を書きます


.code example-1.go /IS FUNCTION START/,/IS FUNCTION END/




* 使う側

.code example-1.go /USE IS FUNCTION START/,/USE IS FUNCTION END/







* errorとは

    type error interface {
        Error() string
    }

という簡単なインターフェースです。







* errorsパッケージ

標準パッケージにerrorsというパッケージが存在します。

errros.New(string)を持っており、生成することができますが、
別にfmt.Errorf()と大した違いがあるわけではありません。

定数的にパッケージを作る時は上位、
自分のエラーを作る時に下ってイメージでしょうか？



* おそらく一番使われているerror系パッケージ


github.com/pkg/errors
golang.org/x/xerrors

この２つだと思います。

これらを使用している人気のある(活発な)ライブラリは1.13が出たら
サポート状況によってこれらを使用しなくなってくると思います。

* 注：ここからのコードは1.13です。

現在は1.12ですので、ここからの実装は動作しません。
サンプルの動作はtipを利用しています。

もちろんですがerrors.New()はなくなっていません。

* Wrapが可能になります！

前述の問題であったエラーのWrapが可能になります。



ラップが可能になります。






* Is()





* As()





* Unwrap()







* logのお話

* おそらく時間が足りないので

ということでとってつけたlogの話になります。





