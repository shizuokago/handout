A Type of Go
Shizuoka.go
29 Oct 2016
Tags: shizuoka_go,golang

secondarykey
Programer
admin@localhost
http://github.com/secondarykey
@secondarykey

* 自己紹介

- name:secondarykey
- job:Programer
- Twitter:secondarykey
- GitHub :secondarykey

* Shizuoka.go

久しぶりの開催です
その間、五反田行ったり、茅ヶ崎行ったり、色々してました。
やってない間の活動はブログに書いてます。

.link https://shizuokago.appspot.com Shizuoka.goブログ

ちなみにこのブログもGoで書かれています
・・・このブログの話ってShizuoka.goで話したっけ？

* Go言語の特徴

- 静的型付け
- コンパイルが速い
- 軽い並行処理
- クロスコンパイル
- GoogleAppEngineで仕様できる

そしてなんといっても

* Gopher君かわいい！

.image model-sheet-gopher.jpg _ 700

.link https://www.dotconferences.com/blog/birth-of-a-giant-gophe://www.dotconferences.com/blog/birth-of-a-giant-gopher


* 様々な現場でGo

いろんな場所で使われています。
以前は海外の製品等を紹介していましたが、日本でもかなりの数が使われてくるようになった印象です。
もし気になるのであればGoConの資料等を見てみるとわかるかもしれません。

.link http://gocon.connpass.com/ GoCon(Connpassグループ)

* 本日のお題 

- 型の話
- Datastoreで検索エンジンを作ってみた

となっています。
LTある方いれば言ってください

懇親会の参加？？？


* 基本型

* Basic Types

- bool
- string
- int  int8  int16  int32  int64
- uint uint8 uint16 uint32 uint64 uintptr
- byte rune 
- float32 float64
- complex64 complex128

* 型の後ろの数

int などに32,64とありますが、
intと宣言した場合、動作するマシンのCPUのビット数に依存します

先日、64ビット機以外では動かさないだろうと思ってTwitterIDをintで受けていたら、32ビット機で動作させたら久しぶりにあふれました><

* それぞれの型へのキャスト

int(x),float64(x)などでそれぞれをキャストできます
int -> stringなどの変換は

    strconv.Atoi("-42")
    strconv.Itoa(-42)

    strconv.ParseBool("true")
    strconv.FormatBool(true)

で変換が可能です。単純な文字列変換なら

    fmt.Sprintf("%d",-42)

とかでも可能です。

* 宣言での型記述の省略

Goでは

    var hoge int

という記述も行えますが、多くは

    hoge := 0

という風に記述して型を省略することができます

関数の戻り値なども型を宣言する必要がないので非常に楽です

私がGoが好きな点の１つです

* ゼロ値

Go言語は宣言時に「ゼロ値」で初期化されます

   int = 0
   string = ""
   bool = false

が基本的なゼロ値です。

ポインタなどはnilで初期化されます


* 定数

    const HOGE = 123

という風に記述します
Goの定数は型を記述せずに書くことができます。
コンパイラがコンパイル時に型を決定してくれるので以下の関数どちらのどちらにも設定することができます。

    func needInt(x int) int { return x*10 + 1 }
    func needFloat(x float64) float64 {
        return x * 0.1
    }

    needInt(HOGE)
    needFloat(HOGE)
    
* Arrays,Slices

GoはArrayとSliceは明確に型として違うものとなります

    var array [10]int
    var slice []int

例えば関数を

    func hoge(array [10]int) {
    }

と宣言してしまうと、その数個にあった引数でしか受付なくなります

    func hoge(array []int) {
    }

よっぽどの理由がない限りArrayは使わないと思います。

* Sliceの生成

    s := []int{2, 3, 5, 7, 11, 13}

という風に宣言できます
多くは初期値はない為

    s := make([]int,5)

という風にmake()を使って準備します。
len(),cap()などで長さなどを知ることをできます


* Slice(Array)の扱い

    s = s[1:4]
    s = s[:2]
    s = s[1:]

のようにSliceからSliceを抜き出すこともできます
上から添え字1-4文字目まで、先頭から2文字目まで、添え字1~最後までとして抜き出すことができます。

要素の追加には

    func append(s []T, vs ...T) []T    

が存在してそのあたりを話すと長くなるので

.link https://docs.google.com/presentation/d/1esGfdcsNXPUmiGOF9-Y5Q4D9ttYqKtngoGcTz9e3-UI

辺りを参考にしてください

* 可変引数とスライス

Goの関数には可変引数が存在します。

    func Hoge(s ...string) {
    }

可変引数にスライスを渡す場合は

    s := []string{"1","2"}
    Hoge(s...)

として呼び出すことができます

* Maps

マップもあります。

    var m map[string]string

キー値を[]に書いて入れる値を後ろに記述します

    var m = map[string]string{
        "secondarykey": "Gopher",
        "polidog":  "PHPer",
    }

という風に初期化できます

    m["hogedigo"] = "Gopher"

という風に代入でき、

    delete(m,"secondarykey")

と削除できます

* Mapの判定

    val := map[key]

として辺りを取得することもできますが、
Go言語の特徴である戻り値を複数持てるので

    val,ok := map[key]

としてokに存在を確認することもできます。
int,stringはゼロ値が取れるので、キー値だけでは0(もしくは"")が取得できてしまう為、純粋に判定する場合はそういう風にします

* 文字列とbyte,rune

string は []byteです。byte はuint8のエイリアスになります

    str := "string"
    b := []byte(str)
    buf := string(b)

と扱うことができます。(メモリコピーが走る)

len()で文字列を数えるとバイト数になるので
日本語の文字列数などが欲しい場合は

    len([]rune(str))

※runeはint32となっておりUnicodeのポイント
※Go言語の文字列はすべてutf-8扱いになります。

* 関数型

関数も型にする事ができます

    func compute(fn func(float64, float64) float64) float64 {
        return fn(3, 4)
    }
 
と関数を宣言して渡すことが可能です

    zFunc := func(x,y float) float {
        z := x * x + y * y
        return math.Sqrt(z)
    }

    z := zFunc(3,4)
    z = compute(zFunc)

* クロージャ

関数を戻り値などでも扱えますし、クロージャとして扱うこともできます

    func adder() func(int) int {
        sum := 0
        return func(x int) int {
            sum += x
            return sum
        }
    }

    pos := addr()

    pos()
    pos()

でsumを追加することができます。

* type

* type の宣言

- type xxxx struct
- type yyyy interface
- type zzzz [type]

という宣言があります

* type xxxx struct

    type Triangle struct {
        x float64
        y float64
    }

構造体の宣言を行います

* メソッドの追加

    func (t Triangle) Area() float64 {
        return t.x * t.y / 2
    }

という風にfuncの後に構造体を書きます
値を変更する場合は

    func (t *Triangle) Set(x,y float64) {
        t.x = x
        t.y = y 
    }

という風にポインタを使用します(ポインタがないとコピー値になる)

* 埋め込み型

Go言語は派生はありませんが、埋め込み型が存在します

    type Twitter struct {
        http.OAuth1
    }

フィールド名称を記述せずに構造体を書きます
こうすることでOAuth1が持つメソッドをあたかもTwitter構造体で実装されているかのように記述することができます

ただしOAuth1のフィールドにアクセスする際は

    t := NewTwitter()
    t.OAuth1.AccessToken = "aaabbbcccdddeeefff"

というようにアクセスします


* type xxxx interface

インターフェース宣言はメソッドの宣言を羅列していきます

    type Shape interface {
        Area() float64
    }

と宣言する

Area()を持つ構造体はShape interfaceとして扱えます
Go言語ではインターフェースに参加する場合、structが参加を表明する必要はありません。

    func (s Square) Area() float64 {
        return s.x * s.y
    }

と実装すればSquareはShapeで扱えます

* error interface

恐らくGoを書いていく中で一番見るであろうインターフェースはerrorになります。

    type error interface {
        Error() string
    }
    
* 例外のないGo

例外のない(推奨しない)Goのソースは常にerror処理との格闘です。
私も多くのプロトタイプを書く際にerror処理を軽んじて、ドツボにはまることもしばしば
先日も

    n,err := fmt.Scanln(buf)

で苦しみました
なのでerror処理は非常に重要になってくるわけですが、先日のGoConであったプレゼンがあります。

.link http://dave.cheney.net/paste/gocon-spring-2016.pdf

もし、Goを書き始めてエラーに悩む場合はこれを読むといろいろ勉強になると思います

* nil は単純なnilではない

実はnilという値は型を持っていて

    var x *int32
    var y *int64
    x == y //false

となります

これがerror処理で起こり得るので注意が必要です

.link http://shizuoka-go.appspot.com/entry/6fdfa8bd-7fa6-4d73-b990-af10b88c59cb Goのハマりどころにハマる男

* Stringer interface

次に代表的なのはfmt.Stringerかな？と思います。

    type Stringer interface {
        String() string
    }

その型の値等を出力する際に使用します。
fmt.Xprintf()やfmt.Xprintln()の引数はStringerかどうかを見ており、
通常structを渡した場合、その値を羅列はしてくれますが、どの変数がどの値か？等は見えません。
String()を実装しておくとデバッグ時に効率がよくなるのは確かです


* type Zzzzz [type]

Go言語は型を再度宣言することができます。
例えば

    type Hoge int

    type (h Hoge) Float() float64 {
        return float64(h)
    }

という既存の型にメソッドを追加したりすることができます


* 構造体をtypeで書き換えた場合

先ほど埋め込み型の部分で実装していた時に少しハマったんですが、１つだけ埋め込み構造体(Zzzzz)を持つ構造体(Xxxxxx)があったので

    struct Xxxxx Zzzzz

として、流用しようとしたのですが、無理でした。
フィールドは直接呼び出せるのですが、メソッドが使用できませんでした。

* ソートを使ってみる

sortパッケージに存在するsort.Sort()の引数はsort.Interfaceになっています。

    type Interface interface {
        Len() int
        Less(i, j int) bool
        Swap(i, j int)
    }

スライス等をソートしたい時に使えるわけですが、

    type SortInt []int

SortIntに３つのメソッドを追加してsort.Interfaceになり、

    sort.Sort(s)

と呼び出してソートが行えます

実際にはsortにsort.IntSliceという型やsort.Ints()という宣言があるのでそのまま[]intを渡してソートできます(float64,stringも用意されています)

* 実装例

    func (s *SortInt) Len() int {
        return len(s)
    }

    func (s *SortInt) Less(i,j int) bool {
        return i < j
    }

    func (s *SortInt) Swap(i,j int) {
        s[i],s[j] = s[j],s[i]
    }

降順にするReverseなどもあります

    s := []int{5, 2, 6, 3, 1, 4}
    sort.Sort(sort.Reverse(sort.IntSlice(s)))


* interface{}型

何でも入るような型はinterface{}で行います
すべての型が入るので便利ですが、すべての型が入るので困りものです

   func handle(x interface{}) {
      fmt.Println("%x",x) 
   }

* ジェネリックス

たびたび話題になりますがありません。






.link https://golang.org/doc/faq#generics

* 型アサーション

interface{}型はそのままで使用することは不可能ですので、

    i,ok := x.(*sort.Interface)

という風に変換することができます
okには変換可能かが返ってきます

    switch x.(type) {
    case int:
    }

として、色々な型の場合を想定して処理をすることもできます

* リフレクション

標準パッケージ「reflect」によってリフレクションを行うことが可能です。

    rv := reflect.ValueOf(x)

と行うことで、reflect.Valueを作成できます

    rv.Type()
    rv.Kind()

で型の情報を取り出すことができます

* フィールドへのアクセス

    xv := rv.Field(0)

でフィールドの取得を行えます。

    xv.Int()
    xv.SetInt()

で取得、設定は可能ですがintでない場合はpanicなので

    if xv.Kind() == reflect.Int {
        i := xv.Int()
    }

と書きます
動的に構造体を変更することは不可能です

* reflectのパフォーマンス

reflectは確かに便利です。多くのフレームワークなどが使っていますが、多用するとパフォーマンスに影響が出てきます。

私感ですが、Goがパフォーマンスがいいため、reflectで動作するフレームワークなどは毛嫌いされる傾向にあるような気がします。
実際go generateを使ってコードを生成する方向に多くのフレームワークが向かっている気がします


