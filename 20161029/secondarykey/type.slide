Type of Go
Shizuoka.go
29 Oct 2016
Tags: shizuoka_go,golang

secondarykey
Programer
admin@localhost
http://github.com/secondarykey
@secondarykey

* 自己紹介

- name:secondarykey
- job:Programer
- Twitter:secondarykey
- GitHub :secondarykey

* Shizuoka.go

久しぶりの開催です

やってない間の活動はブログに書いてます。

.link https://shizuokago.apspot.com

* 本日のお題 

- Type of Go (型の話)
- Datastoreで検索エンジンを作ってみた
- LT

となっています

* Go言語の特徴

- 静的型付け
- コンパイルが速い
- 軽い並行処理
- クロスコンパイル
- GoogleAppEngineで仕様できる

* 様々な現場でGo

いろんな場所で使われています。
以前は海外の製品等を紹介していましたが、日本でもかなりの数が使われてくるようになった印象です。

もし気になるのであればGoConの資料等を見てみるとわかるかもしれません。

* 基本型

* Basic Types

bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte

rune 

float32 float64

complex64 complex128

int()などとキャストできます

* Ex:Suffix Number

int などに32,64とありますが、
intと宣言した場合、動作するマシンのCPUのビット数に依存します

先日、64ビット機以外では動かさないだろうと思ってTwitterIDをintで受けていたら、32ビット機で動作させたら久しぶりにあふれました><


* Arrays,Slices

GoはArrayとSliceは明確に型として違うものとなります

    var array [10]int
    var slice []int

例えば関数を

    func hoge(array [10]int) {
    }

と宣言してしまうと、その数個のあった引数でしか受付なくなります


    func hoge(array []int) {
    }

よっぽどの理由がない限りArrayは使わないと思います。

* Sliceの生成

    s := []int{2, 3, 5, 7, 11, 13}

という風に宣言できます
多くは初期値はない為

    s := make([]int,5)

という風にmake()を使って準備します。
len(),cap()などで長さなどを知ることをできます

* Slice(Array)の扱い

    s = s[1:4]
    s = s[:2]
    s = s[1:]

のようにSliceからSliceを抜き出すこともできます
上から添え字1-4文字目まで、先頭から2文字目まで、添え字1~最後までとして抜き出すことができます。

append()による追加など話だすとキリかなくなるので、

.link https://docs.google.com/presentation/d/1esGfdcsNXPUmiGOF9-Y5Q4D9ttYqKtngoGcTz9e3-UI

辺りを参考にしてください

* Maps

マップもあります。

    var m map[string]string

キー値を[]に書いて入れる値を後ろに記述します

    var m = map[string]string{
        "secondarykey": "Gopher",
        "polidog":  "PHPer",
    }

という風に初期化できます

    m["hogedigo"] = "Gopher"

という風に代入でき、

    deletem(m,"secondarykey")

と削除できます

* Mapの判定

    val := map[key]

として辺りを取得することもできますが、
Go言語の特徴である戻り値を複数持てるので

    val,ok := map[key]

としてokに存在を確認することもできます。
int,stringはゼロ値が取れるので、キー値だけでは0(もしくは"")が取得できてしまう為、純粋に判定する場合はそういう風にします


* Ex:文字列とbyte,rune

string は []byteです。byte はuint8のエイリアスになります

    str := "string"
    b := []byte(str)
    buf := string(b)

と扱うことができます。(メモリコピーが走る)

len()で文字列を数えるとバイト数になるので
日本語の文字列数などが欲しい場合は

    fmt.Println(len([]rune(str)))

※runeはint32となっておりUnicodeのポイント
※Go言語の文字列はすべてutf-8扱いになります。

* 関数型

関数も型にする事ができます

    func compute(fn func(float64, float64) float64) float64 {
        return fn(3, 4)
    }
 
と関数を宣言して渡すことが可能です

    zFunc := func(x,y float) float {
        z := x * x + y * y
        return math.Sqrt(z)
    }

    z := zFunc(3,4)
    z = compute(zFunc)

関数を戻り値などでも扱えますし、クロージャとして扱うこともできます

* type

* type の宣言

- type xxxx struct
- type yyyy interface
- type zzzz int(予約語)

という宣言があります。

* type xxxx struct


    type Triangle struct {
        x float64
        y float64
    }

構造体の宣言を行います

* メソッドの追加

    func (t Triangle) Area() float64 {
        return t.x * t.y / 2
    }

という風にfuncの後に構造体を書きます
値を変更する場合は

    func (t *Triangle) Set(x,y float64) {
        t.x = x
        t.y = y 
    }

という風にポインタを使用します

* 埋め込み型

Go言語は派生はありませんが、埋め込み型が存在します

    type Twitter struct {
        http.OAuth1
    }

フィールド名称を記述せずに構造体を書きます
こうすることでOAuth1が持つメソッドをあたかもTwitter構造体で実装されているかのように記述することができます

OAuth1のフィールドにアクセスする際は

    t := NewTwitter()
    t.OAuth1.AccessToken = "aaabbbcccdddeeefff"

というようにアクセスします

* type xxxx interface

インターフェース宣言はメソッドの宣言を羅列していきます

    type Shape interface {
        Area() float64
    }

と宣言するるArea()を持つ構造体はinterfaceとして参加できます
Go言語ではインターフェースに参加する場合、structが参加を表明する必要はありません。

    func (s Square) Area() float64 {
        return s.x * s.y
    }

とすればSquareはShapeであることになります

* error interface

恐らくGoを書いていく中で一番見るであろうインターフェースはerrorになります。

    type error interface {
        Error() string
    }
    
* Ex:例外のないGo

例外のない(推奨しない)Goのソースは常にerror処理との格闘です。
私も多くのプロトタイプを書く際にerror処理を軽んじて、ドツボにはまることもしばしば
先日も

    n,err := fmt.Scanln(buf)

で苦しみました
なのでerror処理は非常に重要になってくるわけですが、先日のGoConであったプレゼンがあります。

.link http://dave.cheney.net/paste/gocon-spring-2016.pdf

もし、Goを書き始めてエラーに悩む場合はこれを読むといろいろ勉強になると思います

* Stringer

次に代表的なのはfmt.Stringerかな？と思います。

    type Stringer interface {
        String() string
    }

その型の値等を出力する際に使用します。
fmt.Xprintf()やfmt.Xprintln()の引数はStringerかどうかを見ており、
通常structを渡した場合、その値を羅列はしてくれますが、どの変数がどの値か？等は見えません。
String()を実装しておくとデバッグ時に効率がよくなるのは確かです


* interface{}型

何でも入るような型はinterface{}で行います






すべての型が入るので便利ですが、すべての型が入るので困りものです

* Ex:Sort

sortパッケージに存在するsort.Sort()の引数はsort.Interfaceになっています。

    type Interface interface {
        Len() int
        Less(i, j int) bool
        Swap(i, j int)
    }

スライス等をソートしたい時に使えるわけですが、

    type SortString []string

と実装をして

    func (s *SortString) Len() int {}
    func (s *SortString) Less(i,j int) bool {}
    func (s *SortString) Swap(i,j int) {}

を実装するとスライスを扱うようにソートを実現できます
※実際にはsortにsort.StringSliceという型やsort.Strings()という宣言があるのでそのまま[]stringでも渡せます(他の単純な型も用意されています)

* 構造体をtypeで書き換えた場合

先日少しハマったんですが、１つだけ埋め込み構造体(Zzzzz)を持つ構造体(Xxxxxx)があったので

    struct Xxxxx Zzzzz

として、流用しようとしたのですが、無理でした。
前述した通り、埋め込みだとメソッドが呼び出せるのですが、宣言を変更でやろうとすると、メソッドが使用できませんでした。


* リフレクション

しばしば話題にあがりますが、
処理速度に問題があります

逆にgo generateを使ってコードを生成する方向に多くのフレームワークが向かっています


* ジェネリックス！

ありません><
