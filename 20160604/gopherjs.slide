GopherJSでJavaScriptをビルドする
polidog が優しく教えてくれるJavaScriptビルドツールのワークショップ
4 Jun 2016
Tags: golang,GopherJS,polidog

secondarykey
Programmer
secondarykey@gmail.com
http://github.com/secondarykey
@secondarykey

* 自己紹介

- Name:secondarykey
- Job:Programer

* Shizuoka.go

* Shizuoka.go

静岡で開催しているGo言語の勉強会です
４月にGoConに参加しまして触発されて先週半年ぶり位に開催しました

.link https://shizuoka-go.appspot.com/ Shizuoka.go

Goは楽しいです

* なによりGopher君かわいい

.image images/gopher.png _ 700
.caption ｶﾜｲｲ

* Go言語でJavaScriptを書こう！

* GopherJS

快適なGoライフを実現する為にJSerのみなさんに、今回提供するネタは「GopherJS」です

- Go言語で書いてJavaScriptを出力する

「GoだけでJavaScript開発が可能」という夢のような話を聞いた割に少しだけほおっておきました。そんなある日、とある実装に困っていると、お告げのような言葉が聞こえました。

*「汝、GopherJSを使いなさい」*

確かに使いどころとしては最適だったので触ることになりました


* 動かしてみます

* 簡単なサンプル

まずはGopherJSの基本的なライブラリを取ってきます

    go get -u github.com/gopherjs/gopherjs

Go言語はGit、Mercurialのリポジトリからソースを持ってきて、ライブラリなどとして使用が可能になります。Goナウいですね。
以下は動作させるサンプルコードです

.code sample.go
.caption サンプルプログラム


* サンプルの解説

js.Global = windowオブジェクトになります

    js.Global.Get("document")

とするとdocumentオブジェクトを取得することができます
これらで取得できるオブジェクトは「js.Object」という型になり、そこからJavaScriptのオブジェクトとしてアクセスする。といった形ですべて実装していきます。

js.Object#Get(),js.Object#Call() でプロパティの取得やメソッドの呼び出しを行うことができます
※Setもあります


* JavaScriptの作成

go get時にgopherjsコマンドが作成されていますので

    gopherjs build sample.go

と実行すると

- sample.js
- sample.js.map

が作成されます

* サンプルページから呼び出す

出力したコードをHTMLを書いて呼び出してみます。

.code sample.html

*実際みてみましょう*

* デバッグ画面

.image images/debug.png

デバッグ画面にGoのコードがでます


* 現在バインドしているもの

基本的にはJavaScript上のオブジェクト名さえわかればなんだってできるので、様々な製品がバインドされています

- DOM
- jQuery
- AngularJS
- D3
- ChromeAPI etc

.link https://github.com/gopherjs/gopherjs/wiki/bindings

それぞれがフルに使えるかは少し見ていません。


* できないこと

- 外部ファイルを呼び出す
- ライブラリ(soやCGOなど)を参照するプログラム

この辺りを気を付けさえすれば、様々な動作するものを作成可能です

* 実際に使ってみた話

* とある時に

Shizuoka.go用のブログを作成しました。作成するきっかけは

- 静的なファイル(GitHub)で書くのがいやになった
- Shizuoka.goを広める為
- GAE/Goのお勉強

.link http://shizuokago.appspot.com/

結果、一番苦戦したのはMDLでのデザインでした><

* レンダリングエンジン

このブログではレンダリングに

    golang.org/x/tools/present

を使用しています

これはGo言語で書かれたマークダウンをレンダリングするツールでGo言語のプレゼンテーションではよく見かけるやつです。

    * Title of slide or section (must have asterisk)

    Some Text

    ** Subsection

    - bullets
    - more bullets
    - a bullet with

プレゼンのツールまであるなんてGoは素敵です


* ブログの構成

.image images/proposal.png _ 800

* GAEでの設計の話

ブログに関して言うと、見られるコンテンツになるので、例えば下手な設計を行うと

- Article検索
- Blog検索
- User検索
- presentによるレンダリング
- HTML出力

となるわけです
これでは表示をする際にコストがかかりすぎです

* HTMLを作成しておく

編集した時にHTMLを作成しておき、それを保存しておく
そうすると１つの記事を出力するのに、編集時以外は１つのHTMLを検索するだけになります

- 極力Datastoreへのアクセスを減らす
- 極力CPU処理等を減らす

が可能になり、料金も安くなるわけです

* エディタの構成

記事を書くときにデザインを見ながら書きたかったのでQiitaみたいに2ペインで構成しています

.image images/editor.png _ 800

* サンプル描画処理がコスト高

レンダリングにpresentを使用している為、Go言語が動作する場所(サーバサイド)でしかHTMLを出力することができません
なので実際のHTMLを確認する際に

- サーバサイドを呼び出し
- レンダリング
- HTMLを返す
- 描画

というサイクルになってしまって、ちょっとコストがかかりすぎます
まぁどうせ俺しか使わないしViewerに更新ボタンつけて都度確認しようかな？と思っていました。


* ここでGopherJSの登場

* presentをJavaScriptとして使用する

GopherJSを使用するとpresentがJavaScript上で呼び出せるのでクライアントサイドでHTMLを出力することが可能です

マークダウン以外は変更はほぼないですし、記事のデザインを変更する要素はマークダウンしかないので基本的にはクライアントサイドで描画できるはず！

* jQueryバインドを選択

実際にはjsだけで行けたんですけど、gopherjsの仕組みがわかる前だったので、比較的簡単に動作してくれたjqueryバインドを選択しました

    go get github.com/gopherjs/jquery

サンプルにあるのですが、

    var jQuery = jquery.NewJQuery

とjquery.JQueryを生成するメソッドをこの用に定義しておきます。そうすると

    jQuery("#saveBGBtn").On(jquery.CLICK, func(e jquery.Event) {
            jQuery("#file").Call("click")
    })

という風にjQueryライクに記述することができ、ハッピーになれます


* タイマー

再描画処理なのでタイマーを作ります

    go func() {
        t := time.NewTicker(5 * time.Second)
        for {
            select {
            case <-t.C:
                redraw()
            }
        }
        t.Stop()
    }()

こういう時にGoだけで書ける利点を感じました

しかしまぁGoのタイマーってかっこいいよね！

* 非同期処理

もちろんAjaxも使用できます

    ajaxopt := js.M{
        "type":     "POST",
        "url":      "/admin/article/" + u + "/" + id,
        "dataType": "json",
        "data":     data,
        "success": func(data map[string]interface{}) {
        },
        "complete": func(status interface{}) {
        },
    }
    jquery.Ajax(ajaxopt)

ちょっと処理等を割愛していますが、こんな感じ。Ajax()はDefferdが返ってきます

* 肝心のレンダリングで問題

このブログではデザインを容易に変更できるようにしているので、テンプレートファイルは静的なファイルを使っています。
GopherJSではそれを読み込むことができません。
なので少しややこしいのですが、「テンプレートファイルを変数化する為にGoファイルをテンプレートにして、テンプレートファイルを埋め込む処理」を作成しました

    const TMPL       = `
    {{define "root"}}
    <!doctype html>
    <html lang="en">
      <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
    ・・・・`

まぁ単純に言うとGoファイルの中にテンプレートファイルを変数にする処理を作ったってわけです

* デプロイに問題

とこれで動いてくれるようになったのですが、まだ開発中、デザイン中のブログだったので、テンプレートやエディタの変更を行った時に、

- エディタ処理にtemplate埋め込み処理
- エディタ部分をgopherjsでのビルド
- ファイル名称変更(注)
- JavaScriptファイルを正式な位置に移動

を行う必要があったのでデプロイコマンドを作成します

    go run cmd/deploy.go

これでこの作業の手間を省きます。Goは簡単にコマンドもかけるので便利です。
※マップされるxxxx.goをGAE上に入れてしまうと、Goのコンパイルエラー(パッケージ)が発生してしまうので「xxx.go.map」という名称に変更する必要がある

* グーッドウィドゥム

しかし先ほどのテンプレート変数が更新されなくて、開発リズムが狂ってしまう。
そう！gulpが行うようなwatchが必要なわけです


* そこでfsnotify！

ファイルシステムを監視する為のライブラリです

    go get github.com/go-fsnotify/fsnotify

で取得し、生成します

    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        return err
    }
    defer watcher.Close()

* ディレクトリの指定

    監視対象のディレクトリを指定します

    err = watcher.Add("./cmd")
    err = watcher.Add("./app/templates/entry")

ファイル単位ではできないっぽかったです

* 監視

    for {
        select {
        case event := <-watcher.Events:
            go notify(event)
        case err := <-watcher.Errors:
            done <- err
            return
        }
    }

今回のイベントは fsnotify.Write のみが対象ですが、

- Create
- Remove
- Rename
- Chmod

等も取得が可能です。


* 実行

コマンドを作って実行します

    go run cmd/watcher.go

で対象ファイルが修正されたら、デプロイコマンドが実行されるようになります

こんなこともできるのでGoはすばらしい

* ちなみに

今回はデプロイ時に手を加える部分が多かったのですが、
単独でGoファイルを監視する機能をGopherJSも持っています。

    gopherjs -w build sample.go

として単純にwatchすることができます

* 比較

GopherJSはbuild時に「-m」でminifyしてくれます
※コード読む限り、オリジナルでminifyしている

ちなみにですがgulpでminifyしたら

元ファイル -> 68.5kB
GopherJS -> 51.0kB 
gulp -> 

となりました

* GopherJSの評価

- Goのコードで書ける部分は非常に便利(DOM操作だけではあまり意味がない)
- import が増えるとどんどんファイルが重くなる
- 書いてるとJSっぽくかけ過ぎて、JSでいいかな？って思う
- ファイルサイズがシビアな現場では実用的とはいえないです

個人的には

- Chrome拡張
- Electron

等を作成する時に使うのが適しているのかな？と思っています

* 結論

Goは楽しいよ

