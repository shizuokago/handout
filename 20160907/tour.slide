Let's Go out to Tour.
Gotanda.go
7 Sep 2016
Tags: golang,gotanda_go

secondarykey
Programer
admin@localhost
http://github.com/secondarykey
@secondarykey

* 自己紹介

- name:secondarykey
- job:Programer
- Twitter:secondarykey
- GitHub :secondarykey

Shizuoka.goを開催しているものです。

五反田には縁もゆかりもありませんが、
怖い人に脅された人に脅されて今回立つことになりました><

* Gotanda.go

本日はハンズオン形式で

.link https://tour.golang.org/welcome/1 A Tour of Go

をやっていきます

時間は１時間３０分いただいております。
進められるところまで進めていきたいと思います。
質問、トイレなども自由に行ってかまいませんが、


* Go言語概要

* 特徴

2009年に生まれたGoogle製の言語
最近の言語の中では比較的新しく様々な言語の良さを取り入れています

- コンパイル速度
- GCあり
- 軽量な並行処理
- クロスコンパイル

.caption そしてなにより！

* Gopher君かわいい!

.image gopher.png


* Go言語の得意なこと

* 多くの機能が存在

私自身は言語としてGoが好きなんですけど、

- Local Web
- GoogleAppEngine
- GoMobile(iOS,Android)
- NaCl
- Plan9,Solaris

などたくさんのことを行うことができます。

* どこで使われているか？	

案外、いろんな製品の裏側で動いています

- vitess
MySQLのロードバランサ(YouTube)

- Doozer
PaxosのGo実装(Heroku)

- Docker
Linux Container Engine

- etc

* GoCon(ごーこん)

いわゆるごーこんに出ると数多くのプロダクトで使われていることがわかると思います。次回はまだ決定してませんが、もし興味がある方は参加されてみるとよいと思います。


* ということで

ハンズオンに入っていきたいと思います

- Welcome 1-5
- Basics 1-17
- Flow Control 1-14
- More Types 1-27
- Methods 1-26
- Concurrency 1-11

うち何枚かは〆だったり、省略したりします
表題の数値がページ、Exと書いてあるのは書いてないことです
途中演習を飛ばしたりしますが、解答例は
$GOROOT/misc/tour/solutions にあります

* Go言語の世界へようこそ(5)

* 1.機能の説明

ここではTourの動かし方などをやっていきます

- Syntax on/off
- Reset
- Format
- Run
- prev/next

言語の説明は次の章からです

* Ex:Goコマンド

本日はWeb上で動作させますが、基本的にはSDKダウンロードして
コマンドでコンパイルしたり動作させたりします

- go run
- go build
- go fmt
- go get ~
- go test
.caption 代表的なコマンド

* Ex:環境設定

ローカルで動作させる場合は環境変数を２つ準備してあげる必要があります

- GOROOT
Go SDKの場所を設定します

- GOPATH
go get で取得してきたライブラリの置き場

GOROOT/binにgoコマンドがあります

* 2.Go local

少し前までは日本語は古かったのですが、今は日本語も大丈夫ですので、自分のやりやすい言語でやってください。

* 3.Go offline

Tourはオフラインでも実行することが可能です
先ほどの設定を行い、go tool tourを実行するだけでローカルにサーバを用意することもできます。

* 4.The Go Playground

Tourは

.link Playground https://play.golang.org/

という機能で実現しています
Web上でGoを実行する仕組みです

注：時刻は固定なので注意が必要です
※乱数は乱数にならない

* 5. Tourの紹介終わり

まぁここは特に問題ないと思います


* まずは基本から(17)

* 1.パッケージ

Goの処理はすべてパッケージに書いていくのでpackageから始まります
package mainは実行ファイルが呼び出す最初の処理で、func main()は必ず必要です
※GAEなどは違う

importしてあるfmt,math/randを標準パッケージと呼びます
$GOROOT/src にソースはあります

読み込んだパッケージのメソッドの呼び出し方法が
ここに書かれています

fmt.Println()は標準出力です
math/rand#Intn()を使用していますが、前述の通り乱数は発生しません

* Ex:パッケージの概念

math/rand の様にディレクトリを作成すると
そこにパッケージを作成することができます

GOPATHを特に指定してない状況なら相対パスで指定できます

パッケージにはinit()という予約された処理があり
パッケージを読み込んだ時の初期化として動作させることができます

```
func init() {
}
```


* 2.インポート

import は () で書き込んで行きます
左にある様に１行ずつ書いてもOKです

ちなみに使ってないパッケージはコンパイルエラーになります

* Ex:インポートのあれこれ

import には様々な書き方があります

.code import.go 

一番上が別名を付ける方法です
"."は、先ほどfmtとかを書いていましたが、そのパッケージのメソッドを同一階層っぽく使えるようにすることが可能になります
"_" は読み込むがメソッドは使わない。という難易度の高いやつです
init()だけをやらせたいとかいう場合に使います


* 3.パッケージメソッドの使用

実行してみてください。

エラーが起こります。
Goにはアクセス指定子はないのですが、最初が大文字か小文字かで
別のパッケージから呼び出せるかを決定します

別のパッケージからアクセスする場合は大文字から開始します
これは後述する構造体などにも適用されます

* 4-5.関数の書き方

- 4 基本的な書き方

func ~~~() {} という書き方をします
引数は変数名 型と書いて、戻り値を書きます

- 5 引数の型省略

引数の型の省略
２つ以上同じものが続く場合は省略して記述することも可能です

* 6-7.戻り値

- 6 複数の戻り値

Goの特徴の１つ、複数の戻り値を指定します
,区切りで処理してください

後述しますが、Goには例外が存在しません
多くのGoのプログラムは複数の戻り値を利用して、errorを伝搬して処理します
※俗に言うエラー地獄

- 7 名称を指定して変数で扱う

戻り値に名前を付けて関数内で処理することが可能です
この際に戻り値を指定する必要はありません

* 8-10.変数の宣言

- 8 基本的な宣言

var を利用して変数を宣言します
パッケージ内変数、ローカル変数になります

- 9 初期値

変数の初期化する場合そのまま横に記述していきます
型は勝手に解釈されます

- 10 一番やるやーつ

var も書かずに「:=」で簡単に宣言できます
関数の戻り値などはこれで処理することが多いです

* 11-12.基本的な型

- 11 型一覧

%Tで型を表示しています

<< シフト演算
cmplxは複素数を利用するときのパッケージです
※64ビット左に変更して-1して一番大きな数値を取得しています

だいたいint64などを使うことが多いですが、
Cを呼び出すようなプログラムを書く時には相手の型を合わせたりする必要があるのでint16,unit16などを使うこともあります。

- 12 初期値

代入しないときの値は基本0です。
文字列はnil(NULL)が存在しないので””になります


* 13-14.変換方法

- 13 変換方法

uint(),float64()などで行う

文字列と数値はstrconvパッケージを使うが
fmt#Sprintf()などを使うのもよし

- 14.型を省略した場合の型

通常,整数はint,小数はfloat64,複素数型はcomplex128

* 15-16.定数

- 15 宣言

constをつけると勝手に型を判断してくれます。
パッケージ内定数と関数内での宣言とあります

:= ではダメです

- 16 優秀な型変換

constは厳密にいうと型を持っていないので
このように整数を受け取る関数や小数点を受け取る関数に
そのまま渡してもコンパイルエラーにはなりません


* 17 お疲れ様でした

これで基本編は終了です
少しGo書き方もわかってきたと思います

ご質問等あれば受け付けます


* 制御してみよう！(14)

* 1-4.for文

- 1 基本的な書き方

初期化、継続条件、ループ時の処理
breakすると抜けれます
()は必要ありません

- 2 条件のみ記述

条件だけでも書けます

- 3 While

2の表現はwhileで、;は実は必要ありません
2でfmtを打てばわかりますが、;は消えます

- 4 永久ループ

forを書くのみです(forever)

* Ex:goto文

ちなみにですが多重ループみたいなのをこんな感じで抜けることが可能です

.code goto.go  /^func main/,/^}/

goto ステートメントもあるので

    goto L

なども実行可能です（上記例では永久ルー\プ）

* 5-7.if文

- 5 基本的な書き方

if にも()は必要ないです

- 6.if内宣言

宣言省略を利用して;でつなげることで
そのままif内のみで使用することが可能です

- 7.スコープ

else,else if でも使用できます
if 後に変数を使用しようとするとコンパイルエラーになります

* 8.演習:平方根を求めよ

ニュートン法を用いて、平方根を求めるような処理を書きます
.image newton.png
オリジナルのSqrt()を作成して呼び出してみましょう！

    z = z - ((z^2 - x) / 2z)

この式を10回繰り返すと平方根の近似値が出ます

* 8.解答例

.code sqrt.go  /^func Sqrt1/,/^}/
.code sqrt.go  /^func Sqrt2/,/^}/


* 9-11.Switch文

- 9 基本

GoのSwitchにはbreakは存在しません
次のcaseに入れたい場合は

    fallthrough

が必要です

- 10 判定に計算式

式や関数を書いて判定することもできます
この場合は曜日判定ですね

- 11 条件なし

条件式をなしにして、caseに条件を書くことも可能です

* 12-13.defer

- 12 基本

deferは呼び出されてすぐに処理するのではなく、
そのスコープが終わる時に呼び出される処理を書きます
ただし関数に関数を渡すような処理は関数が実行されてから
deferに渡される為、注意が必要です

.code defer.go 5,11

- 13 LIFO

deferは貯めこまれて行き、処理する順序はLIFOになります

* Ex:Goのエラー処理

前述で少し言いましたが、Goには例外処理がありません
プロセスを継続しがたい問題が発生した時は

    panic

が発生します
panic()で明示的に起こすことも可能です

このpanicを例外的に扱う機構としてrecover()が存在します
例を次のページにあげてはおきますが、
以下のことが標準ライブラリに書いてあります

- 外部に公開するAPIはpanic()を伝えない
- スタックが深くなるような処理を完結に処理する為だけに使用する

 なので、しっかりした理由がない場合はrecover()は使用しません

* Ex:例外処理の例

.code recover.go  /^func main/,/^}/

panicが発生してもdeferは呼び出されるので
panicが起ころうが処理を継続したい場合にdeferし、
recover()にエラー原因があるはずなので
それを元に業務に戻れるようなら戻すような処理をします

* 14.お疲れ様でした

制御文を書けるようになったということは
簡単な処理はすべてできるようになったということですね

Gopherと呼ばれるまでもう少しです


* もっとくわしく(27)

* 1.ポインタ

みんな大好きポインタです
Goにもポインタが存在します
ポインタなので代入なしの初期値はnilになります

この例ではiのアドレスをpにして、
pの値を出した時はiと同じになり、
pの値をいじるとiも変更になる

同じくjのアドレスを入れてpをいじるとjも変わる

安全に行くためにポインタ演算はありません

* 2-3.構造体1

- 2 基本的な書き方

Goにはクラスはありませんが、構造体があります

.caption 多態性は一応確保

標準出力するとフィールドの全部を出してくれます

- 3 読み込み方

「.」を使うと構造体の中身にアクセスできます
前述したように構造体のフィールドも小文字にしておくと
他のパッケージからはアクセスできません

よってJsonなどの変換を行うような時は
必ず大文字にする必要があります

* 4-5.構造体2

- 4 ポインタでの扱い

ポインタでも扱えます

- 5.構造体の初期化

フィールドの名前を書いて初期化することを推奨します(２番め)
新たに構造体にフィールドが追加になった時に
明示的に何が初期化されてないかがわかるからです

* 6-8.配列とスライス

Goには配列とスライスは明示的に型が違うので注意が必要です

- 6 配列

要素数があるものを配列といいます
変数はポインタ扱いされます(スライスも)
要素数が固定なので特別なデータにしか使わないです

- 7 スライス

逆にスライスは要素数がないものです
ここでは配列から取り出しています。

- 8 配列からの取り出し

配列から取り出した場合は参照になります

- 9 初期化

そのまま値を入れることも可能です

* 10-13.スライスの扱い

- 10 スライスをスライス

スライス一部をスライスの一部として切り取ることが可能です
0や最大値は省略することが可能です

- 11 len()とcap()

長さと容量を持っています
cap()はメモリ上でどれだけ確保しているか？

なので大量に操作する前提の処理では多めに確保しておいたほうが良いです

- 12 スライスはnil

スライスは初期化を行わないとnilを示しています

- 13 make()

スライスはmake()で領域を確保します

    make(型,長さlen,領域cap)

です

* 14-15.スライスの扱い２

- 14 ２次元スライス

２次元で取り扱うことも可能です

- 15 追加

append()という関数があるのでそれで追加します
要素は可変引数なのでいっぱい追加できます
詳細は後述

削除はスライスをスライスしたりして、うまく対応します

   src := []int{1, 2, 3, 4, 5, 6, 7}
   src = append(src[:1], src[2:]...)

* Ex:スライスの領域

append()の戻り値はスライスです
ここからわかりますがappend()をするとスライスを再定義します
スライスはポインタなので関数に引数で渡して
append()して返すようなことをすると最終的に
操作していたものと違うものが戻ってきます(保証されない)
※実際はCapの関係でポインタを変更するかが決まる

また他の言語同様、領域確保(make)を何度も行うと
処理が遅くなるので、make()時に想定される範囲を確保しておくことが
速度の向上につながります

大きい物作り始めた時にはじめにひっかかるところなので
注意してください

* 16-17. スライスなどのループ

- 16 Range

スライスなどはforにrangeを利用してループします
rangeはインデックスと中身を返します

- 17 インデックスなどの省略

インデックスのみの時は上の表記
値だけ使う時は"_"を使って行います

* 18.演習：式による描画

Pic関数はpic.Show()の中身から呼び出されます
dx,dyには描画の長さがわたってきますから、
その領域を確保して[][]int8を確保します

ヒント：
二次元配列をyの長さでmake()し、
その次の次元配列をxでmake()して領域を確保します

* 18.解答例

.code pic.go  /^func Pic/,/^}/

XYの式で描画が変わります

* 19-22.マップ

- 19 基本

GoにもMap(連想配列)があります
スライス同様にmake()で初期化しますが、引数は型の指定です

    map[キーの型]値の型

で宣言します

- 20,21 初期化

リテラルならこういう感じで扱います
型は省略できます

- 22 操作

更新、削除、戻り値はこの様に扱います
取得時にそのキー値が存在するか(ok)？を取得できます

* 23.演習：ワードカウンター

さぁマップを使用して、ワードカウンターを作ってみましょう！
wcからWordCount()関数を呼び出してきますので、
引数sの中の文字の数を数えてMapにして返してあげます


* 23.解答例

.code wc.go  /^func WordCount/,/^}/

* 24-26.関数を操作

- 24 変数として扱う

関数を変数のように代入します
関数を関数に渡すことも可能です
※型が同じなら既存のmath.Pow()も渡せます

- 25 クロージャー

adder()を呼び出して、adder()はfuncを返しています
ここからもわかるように
pos,negのそれぞれのスコープでsumの値が扱われます

* 26.演習：フィボナッチ数列

クロージャーを使ってフィボナッチ数列処理を作ってみましょう
fibonacci()で数列を返してくれるような処理を行います

* 26.解答例

.code fib.go  /^func fibonacci/,/^}/

* 27.お疲れ様でした

これで多くの操作ができるようになりました。
次の章で大まかなことは終わるかな？

* 様々な関数の使い方(26)

* 1-3. メソッドを構造体へ

- 1 構造体への追加

クラスは存在しませんが、構造体への追加ができます
func後に構造体と変数(this,me,selfに相当)を書きます

これで構造体のメソッドとして動作します

- 2 通常の関数としての使用

・・・これ最近追加されたんですが・・・いる？

- 3 typeへの追加

Goはtypeで別名にすることができます
そのtypeにもメソッドを追加することができます

これはかなり便利で、良く使う様なMapやSliceなども
別名で宣言しておくと便利に扱うことができるようになります

- 4-7 ポインタにした場合の扱い

- 4 レシーバーをポインタにする

外して実行するとわかりますが、
内部をいじる場合はレシーバーをポインタにします

-5,6,7 関数としての書き直し

ここでもポインタの勉強です

- 8 レシーバーを使う理由

変数を変更する為とコピーされるのを防ぐ為です

* 9-10.interface

Goでの多態性はインターフェースを使用します

22行目のエラーは
VertexのAbs()のメソッドレシーバがポインタである為、
VertexをAbserに代入する場合はポインタでないとエラーが起きます。
※1なので8行目は成功します

GoのInterfaceは宣言をするわけでもなくそのメソッドを持っていると
勝手にinterfaceになれます。これは結構強烈な考え方で、
他人のソースを自分のインターフェースにあてはめることも可能になります
10のWriterがそれですね

* Ex:sortの話

標準パッケージのsortには「Interface」というインターフェースがあります
Len(),Less(),Swap()があり、これらを持っているとInterfaceになり
    sort.Sort()
で並び替えが実行できます

前述したtypeを型変換に使い、それにこの３つを入れるとソートできます

.code sort.go 14,27

* Ex:sortの実行

Len()で長さ、Less()でどちらがどの値か？、Swap()で入替
これを実装するだけでsort.Sort()を実行して並べ替えます

.play sort.go /^func main/,/^}/

* 17-18.interface Stringer

- 17 Stringer

標準のインターフェースは様々ありますが、
一番の代表格はStringerになります

通常構造体をPrintlnなどに渡すと、
内部フィールドの中身をただ返してくれますが、
String()を実装するとそちらの値を返してくれます

- 18.Stringerの実装

ここでは実装しませんが、IPアドレス構造体の標準出力を
IPアドレス形式で出力するような例題ですね

* 19-20.interface error

- 19 error

errorはおそらくGopher達が一番見るinterfaceです
前述していますが、Goは例外ではなくerrorでエラーを伝達していきます

そのインターフェースはError()を持つことだけです
エラーの判定はnilでないことや、その型(値)で判定したりします。

    if err != datastore.ErrNoSuchEntity 

- 20 errorの実装

これも実装は割愛します

* 21-22.interface Reader

- 21 Reader

読み込み処理はReaderを使います
例ではstrings.NewReader()を利用して生成しています
※strings内の構造体の名称もReaderです

- 22 Readerの実装

ここも割愛しますが、
ここだけ解答例がないので出しておきます
終わりを示す場合io.EOFを返すのですが、
ここではエラー扱いされます

* 23.演習：Rot13Reader

.link https://ja.wikipedia.org/wiki/ROT13 ROT13

古代の暗号です（13文字ずらすだけ）
これも割愛しますが、

    io.Copy(Write,Reader)

を使っていますが、Reader#read()が呼ばれ、
Writer#write()で書き込みます

ファイルのコピーなどでよく使う関数です

Ex: WebServerの実装

以前はあったのですが、消えていました。
Goの特徴といってもいいと思いますが、
簡単にWebサーバを立てることができます

* 24-25.Images

- 24 image

Goは標準ライブラリが本当に豊富なので
結構いろんなことを実現できます

画像の編集も用意されています

- 25.Imagesの実装

割愛します

* 26 お疲れ様でした

さぁこれでGoのコードはほぼ読める状態になりました

ついに並行処理に入っていきます

* ゴルーチン！

* 1. 使い方

スレッドのような並行処理を行う場合、ゴルーチンを使います
※unixのスレッドではない

非常に軽量に呼び出せます
使い方は簡単

  go

と関数呼び出しの前に書くだけです！

* 2-3. チャネル

チャネルはゴルーチンでの値をやりとりするのに使われます
ここではsum()の呼び出しをゴルーチンにして、チャネルを渡しています

- 2 使い方

チャネルの生成はmake()で行います

    c <- sum
    <- c

こういう感じで元処理とデータのやりとりを行います

- 3 サイズの指定

スライスのように貯めこむ量を指定して呼び出すことができます
数量を限定することで並行処理の数量を制限することが可能になります

* 4. close

明示的に処理の終了を知らせる為にはclose()で閉じます

ここでは10の長さのチャネルを生成してrangeでチャネルを処理していますが、
fibonacci()でclose()が呼び出されるので、そこでrangeが止まります

例えばここでclose()を行わないと
永遠にrangeが処理を回すことになり、デッドロックで処理が終了します

* 5-6.select

- 5 select

selectはチャネルで使用するSwitchと考えてください

今回のfibonacci()は永久ループをしてcチャネルを待ち受けています
select側でxをチャネルに送り込み、main()側で受け取って表示しています

main()側が10回回るとquitに0が送り込まれ、
select側でそれを受信してreturnしてfibonacci()が終了します

- 6 default

defaultもあり、何もない時はそれを行うという処理もできます
ここではtimeを使い100msでtickを受け取り
処理しない時はdefaultで50ms待ちます
500msでboomが送り込まれ、処理が終了します

- 7,8 バイナリツリー

割愛

- 9 sync.Mutex

一時的に変数にアクセスできるようにしたい時に使います

- 10 Webクローラー

割愛

* 11 お疲れ様でした〜

これでツアーは終了です

Goの良さはわかっていただけましたか？
スクリプト言語のような触りやすさと
コンパイル速度を兼ね備えた絶妙な言語だと
思って私は良く触っています

わからないところなどあったら聞いてください！
