アニメGIF作成で試すGoのチューニング
Shizuoka.go
28 May 2016
Tags: golang,shizuoka_go

secondarykey
Programmer
secondarykey@gmail.com
http://github.com/secondarykey
@secondarykey

* 自己紹介

- Name secondarykey
- Job Programer

* Shizuoka.go

* Shizuoka.go

静岡で開催しているGo言語の勉強会です
ちょっと最近開催していませんでしたが、
Go Conference 2016 Spring で触発されてきたので開催する運びとなりました。
※詳細についてはhogedigoから

* 本日のお題は

- GIFアニメで学ぶGoのチューニング 
- GAE/Goライブコーディング(+GoCon)
- muninプラグインを作ってみた

* Go言語

* 特徴

- 標準ライブラリの豊富さ
- テストなどの標準サポート
- 軽い並行処理(goroutine)
- GAE/Goで動作する
- クロスコンパイル

私の発表では上の３つをお伝えできたらなと思います

* 突然のVJイカスクリュー

* VJとは

クラブでDJが音楽を鳴らしている時に後ろで映像を流す人です

以前、VJをやってみないか？と言われて「やるやる！」と適当に返事をしたら、本当にやる羽目になりまして、どうせやるなら自分でソフトを開発してやってやる！ってなりまして、動画のプログラムを書くことになったわけです。

素直に行くとC++で書くところなんでしょうけど、
Go言語で書いてみようと思ったからさぁ大変です。
実際に作ったソフトの多くはカクカク動く始末で結構苦戦はしています
.caption これはGoのせいではなく、僕のせいです

* 突然のGIFアニメ

基本的にVJソフトでは、動画と動画をエフェクトさせながら切り替える。という処理を行っていくのですが、そういうの見てたら

「GIFのアニメ作れるんじゃない？」
「標準でGIFアニメ作れるじゃん！」

となり少しコードを書いてみたら、激重でした><

普段Webアプリを作成しているとあまり出くわすこともないので、これはチューニングを実際やってみるチャンスだ！って感じていろいろやってみたことを紹介しようかな？と思います。

* 動画の基本

.image images/golf.jpg _ 500

動画データは静止画を連続して流すことで動画として処理をします

- Frame : 静止画
- FPS ：Frame / Second 

アニメGIFも同じ仕組みで静止画を連続して設定することでアニメーションをすることができます


* 対象の動画

.video matrix.mp4 video/mp4

処理する動画(6秒238kb,15FPS = 90コマ)


* まずは作成処理

* コード

.link https://github.com/shizuokago/handout/tree/master/20160528/secondarykey

にあります
cloneしちゃうと以前の発表資料等まで落ちてくるので注意を><

* gif.GIF

とにかくファイルを出力するまでの処理をみていきます

image/gif パッケージをインポートして

.code gif.go /^func createGIF/,/^}/

GIFファイルの作成に必要なgif.GIF構造体を生成します
最低限の２つのフィールドに画像(Image)と次の画像への時間(Delay)を設定します

今回はフレームの数設定していきますが、粗い動画でも良い場合は、フレーム数とその間の時間を調整します

* lazywei/go-opencv

動画から静止画を抜き出すにはgo-opencv というものを使います

GoはGitHubなどに存在するライブラリを

    go get github.com/lazywei/go-opencv

のように取得してつかうことができます。

ただしこのライブラリの使用にはOpenCVのインストールが必要です

.link https://github.com/lazywei/go-opencv 

GitHubのページにOpenCVのインストール方法が書いてあります

OpenCVを利用する理由はVJ用に動画をエフェクトかけたりしやすいからなので、その他のライブラリなどで行った方が速かったりするかもです

* opencv.Capture

.code gif.go /^func getCapture/,/^}/

動画ファイルからキャプチャオブジェクトを取得してきます
このキャプチャから動画の画像がフレームとして取得できます

    opencv#NewFileCapture() 

からキャプチャを生成します

    Capture#GetProperty()

を行い、動画のフレーム数を取得します

* image.Image

.code gif.go /^func getImage/,/^}/

    Capture#QueryFrame()

これでフレームを１コマ取得します

    opencv.IplImage

この構造体がOpenCVにおける画像データになります

    IplImage#ToImage()

Go言語でのイメージライブラリであるimage.Imageに変換できることになります

* image.Plettedの作成

.code gif.go /^func convertGIF/,/^}/

image.ImageからGIF.Image に必要な*image.Palettedに変換を行います

    gif.Encode()

でimage.Imageをメモリデータに変換して、

    gif.Decode()

でimage.Palettedに変換しています

* 出力処理

.code gif.go /^func writeGIF/,/^}/

作成したgif.GIFを

   gif.EncodeAll()

でファイルに出力できます

* コマンドの実行

    go run gif.go

作成したgif.goを実行します
今回はファイル名を固定にしていますが、引数で指定するようにすることも可能です


* Tips:コマンドを作る

Goのコマンドはmain()に記述していきます

.code gif.go /^func main/,/^}/

コマンドを作成する時の留意点として、main()でそれらを呼び出す処理を作成するのではなく、別の関数に梱包して処理を行うようにしておきます。

main()にだらだら書いてしまうとos.Exit()をしてしまった時にdefer処理を行わずに終了してしまう為、こうしておいた方が安全になります

* 計測してみる

* 標準で備わっているベンチマークテスト

Goはテストを標準で書けるようになっており、そのテストの仕組みの中にベンチマークを取ることをできるようになっています

テストは「xxxx_test.go」というファイルを準備して実装していきます

ここではテストには言及しませんが

    TestXxxx(t *testing.T)

という関数を作成し、

    go test 

とすることでテストを行うことができます

* こんな感じで書きます

.code gif_test.go /^func BenchmarkRun/,/^}/

prefixに「BenchmarkXxxxx」と記述して引数に
「*testing.B」を受けるとベンチマーク対象の処理となります

b.Nは実行回数を実行時間で勝手に決めてくれます

* ベンチマークを実行

    go test -bench .

    と行うと

    PASS
    BenchmarkRun-4                 1    76628900177 ns/op
    BenchmarkGetCapture-4        300        4552273 ns/op
    BenchmarkCreateGIF-4     2000000            803 ns/op
    BenchmarkGetImage-4           10      108032663 ns/op
    BenchmarkConvertGIF-4          2      739073450 ns/op
    BenchmarkWriteGIF-4            3      368682900 ns/op

とベンチマーク関数枚に(関数名、実行回数、実行平均値)が出力されます

*run()の実行に76s(1回)!!!*getCapture(),createGIF(),writeGIF()は1回の処理なので
4ms,0ms,368ms程度なので全体からすると無視して良いでしょう

getImage(),convertGIF()はフレーム回数(90)処理するので、実行時間は9.7s,66.5sとなり圧倒的にconvertGIF()が処理を遅くしていることがわかります

* Ex:実行コード内にも埋め込めます

直接コードによる実行も可能です

    result := testing.Benchmark(func(b *testing.B){ run("matrix.mp4","matrix.gif") })

という風に書くことでできます。
一回しか処理を行わないので注意が必要です

* メモリアロケートの数を取得

    go test -bench . -benchmem 

とすればメモリの確保状況も見れます

    BenchmarkRun-4          429710808 B/op  55322519 allocs/op
    BenchmarkGetCapture-4          25 B/op         3 allocs/op
    BenchmarkCreateGIF-4         1536 B/op         2 allocs/op
    BenchmarkGetImage-4       2457664 B/op    307202 allocs/op
    BenchmarkConvertGIF-4     2238888 B/op    307489 allocs/op
    BenchmarkWriteGIF-4       7016184 B/op       276 allocs/op

＊処理時間を省略

見方としては１回の処理でどの程度のバイトをアロケートされるかと、１回の処理でのアロケートの回数となっています

* runtime/pprof

Go言語ではruntime/pprof パッケージを利用して実行時のCPUのプロファイルを作成することが可能です

    cpuprofile := "cpu.prof"
    f, _ := os.Create(cpuprofile)
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()
    
    測りたい処理

と書きます

このファイルを利用してプログラムの状況を確認することができます
※後述

* Ex:Daveさんのパッケージを使う

    go get -u github.com/davecheney/profile

このパッケージを使うと

    defer profile.Start(profile.CPUProfile).Stop()

と書くだけで、実行することが可能で簡単です

.link http://dave.cheney.net/2013/07/07/introducing-profile-super-simple-profiling-for-go-programs

* net/http/pprof

リアルタイムでプロファイルを行う仕組みとして、net/http/pprof が存在します。
例えばWebサーバを立てて処理を監視したい場合などは

    func init() {
        go func() {
            http.ListenAndServe("localhost:6060", nil)
        }()
    }

とすると、指定したポートにプロファイルを出力するWebサーバが立ち上がり常時監視することが可能になります

* テスト時に出力

メモリ、CPUの状況をプロファイリングファイルとして出力することができます
今回はベンチマークを取らないと

     go test -cpuprofile cpu.prof
     go test -memprofile mem.prof 

※両方同時に指定できます

今回は触れませんが、カバレッジとかも取れます(go test -h)

* 解析する

プロファイルを利用して解析していきます

    go tool pprof secondarykey.test cpu.prof
    go tool pprof secondarykey.test mem.prof

を実行すると解析する

    (pprof)

となり、pprofのコマンドが打てるようになります

net/http/pprofで行う場合

    go tool pprof --text http://localhost:6060/debug/pprof/heap

みたいな感じでWeb経由で行います
CPUプロファイルは別途出力する必要があります

* 注意

今回解析を行うものはベンチマークから取得した値になるので、

* CPU(メモリ)の消費量

消費量を見るには

    (pprof) top

を行います。 *top5* とすると上位５個が表示されます

     flat  flat%   sum%        cum   cum%
     68010ms 75.94% 75.94%    70170ms 78.35%  image/draw.drawPaletted
      5680ms  6.34% 82.28%     8270ms  9.23%  runtime.cgocall
      1990ms  2.22% 84.50%     3020ms  3.37%  compress/lzw.(*encoder).Write
      1260ms  1.41% 85.91%     3510ms  3.92%  runtime.mallocgc
       750ms  0.84% 86.75%    10570ms 11.80%  github.com/lazywei/go-opencv/opencv.(*IplImage).ToImage

* 図にしてみる

こういうのはグラフでみたいよねーってことで

.image images/web.png _ 400

    (pprof) web

と行うと図で見ることができます(Graphvizが必要)

* peek

呼び出し元を特定したい場合、

    (pprof) peek 

を使用します

* list

    (pprof) list 

* 詳細は

これらの詳細な見方などは以下を見ることをオススメします

.link https://blog.golang.org/profiling-go-programs

.link http://klabgames.tech.blog.jp.klab.com/archives/pprof1-cpuprofile.html

.link http://klabgames.tech.blog.jp.klab.com/archives/pprof2-cpuprofile.html


* チューニング！

* 注

ここから色々やって処理を見ていきますが、変更はすべてafterディレクトリにあります

* goroutine

Goの並行処理であるgoroutineは低コストで並行処理を行うことができます

    go func() {
    }()

とすることで、呼び出すことが可能になります

* 並行処理




図を挿入





* Ex:並行処理にするにあたって

静止画(*opencv.IplImage)を取り出す処理である

    opencv.Capture#QueryFrame()

を実行している部分をconvertGIF()とは違うループで処理しています
通常の処理であれば、ここは同じループで処理してもOKなのですが、

実際処理を並行にした時にわかったのですが、この処理は同じポインタを返すような処理になっており、溜め込んだデータが最後に処理するフレームのみになってしまい、アニメーションにならないという事実が判明した為、この処理だけは同期で処理しています※よって9.7sはチューンの対象にしません








* まずはWaitGroup

    var wg sync.WaitGroup
    for idx, img := range imgs {
        wg.Add(1)
        go func(ig image.Image, i int) {
            p := convertGIF(ig, i)
            g.Image[p.idx] = p.pal
            g.Delay[p.idx] = 0
            wg.Done()                                                          
        }(img, idx)
    }
    wg.Wait()

一番簡単な方法はこういう感じで書きます。

sync.WaitGroupを作って、Add()で足して、Done()で完了(-1)を報告します
Wait()はそのカウンタが０になるまで処理を待ち受けてくれます

* 処理速度(WaitGroup)

       BenchmarkRun-4                  1   44133686780 ns/op
       BenchmarkGetCapture-4         300       4515983 ns/op
       BenchmarkCreateGIF-4      2000000           782 ns/op
       BenchmarkGetImage-4            10     105893642 ns/op
       BenchmarkConvertGIF-4           2     736907389 ns/op
       BenchmarkWriteGIF-4             3     371185628 ns/op

結果は75s程度の処理が44sで処理を終了しています
その他の処理の基本的な部分はいじってませんので、単純に並行化を行った部分で処理速度が向上をしています

* 注意点

単体の処理速度は
convertGIF()の単体の処理速度は739msなので、getImage()の合計処理10sと合わせると理論値としては12s程度で返って来て欲しいところですが、
各処理のメモリの消費自体を抑えているわけではないので、並行に書きすぎるとメモリなどを使い果たして遅くなる可能性もあります

* Channel

goroutine間でメッセージングを行うための機能です
メッセージング用に構造体を準備します

.code after/gif.go /^type palettedIdx/,/^}/

送信対象になるimage.Palettedとエラー処理用のエラー、
あと配列に設定する為のインデックスを持っておきます

※受信する際の順序が不定になるので、返ってきた順序で設定するとダメです

* convertGIF() の改良

convertGIF()がチャネルに送信できるように改良します

.code after/gif.go /^func convertGIF/,/^}/

* 送信側

    ch := make(chan palettedIdx)
    for idx, img := range imgs {
        go func(ig image.Image, i int) {
            ch <- convertGIF(ig, i)
        }(img, idx)
    }  

まずはチャンネルを生成しています
make(chan 型名) で生成することができます

そこにgoroutineで囲ったところにconvertGIF()に投げます

チャネルに「<-」とするとデータを送信できます

* 受信側

    for range imgs {
        pal := <-ch
        if pal.err != nil {
            return fmt.Errorf("convertGIF() Error%d:%v", pal.idx, pal.err)
        }
        g.Image[pal.idx] = pal.pal
        g.Delay[pal.idx] = 0
    }

convertGIF()の処理が終わると送信されたデータを受信する必要があります
チャネルに「<-」とするとデータを受信できます

* 処理速度(Channel)

BenchmarkRun-4                  1    43746626289 ns/op
BenchmarkGetCapture-4         300        4541198 ns/op
BenchmarkCreateGIF-4      2000000            822 ns/op
BenchmarkGetImage-4            10      108069561 ns/op
BenchmarkConvertGIF-4           2      738840833 ns/op
BenchmarkWriteGIF-4             3      367877829 ns/op

WaitGroupと同等の処理結果が得られました

* 本当は、、、

ここから更にチャネルを利用してチューニングを行いたかったのですが、
ベンチマークからの結論でいうと、gif.Decode()の処理だけが圧倒的に遅く、
gif.Decode()をうまく行わないと少しチューニングできないですね


* GOMAXPROCS

これにより動作するCPU数を設定できます
デフォルトでは１つで動作しています。

端末の最大数を設定するにはruntimeパッケージを利用して

    cpus := runtime.NumCPU()
    runtime.GOMAXPROCS(cpus)

と変更することが可能です
ちなみにベンチマーク実行時は必ず最大数で動作させるみたいです
※-cpu n として実際の数値などで実行することが可能です

* 結論

* gif.Decode()を速くする:(

というお粗末な結果に

- opencv.IplImage#ToImage()
- gif.Decode()
- gif.Encode()

という変換を行っているので

    IplImage -> image.Paletted

の変換を直接やった方が速いって結論に至りました

* が

* がっつり変換コード><

中身を見ると大変なことになっているので
