俺のHTTPが1.1なはずがない！
polidogと学ぶネットワーク
20 Mar 2017

Tags: polidog,golang,http2

secondarykey
Programer
admin@localhost
http://github.com/secondarykey
@secondarykey

* 自己紹介

- name:secondarykey
- job:Programer
- Twitter:secondarykey
- GitHub :secondarykey

* HTTP2

* なんとなく

Webでさえ12年前に2.0なのに、、、、（以下タイトル
って気持ちになったのでタイトルにしました

本日はGo言語の実装を見ながら
HTTP2の特徴だけでも覚えて帰って貰えればと思います。

* HTTP2 is 何？

HTTP2は2015/05にRFCが策定されています。

.link https://tools.ietf.org/html/rfc7540 RFC7540

- 1991 HTTP 0.9
- 1996 HTTP 1.0
- 1999 HTTP 1.1
- 2005 Web2.0 (しつこい
- 2009 *SPDY*
- 2015 HTTP 2.0

* SPDYの存在

HTTP2を語る上で外せない存在である「SPDY」があります
HTTP1.1が古すぎて、遅すぎるってことで2009年にGoogleが発表しました。

発表があった時に、

「こいつらそこまでして世界を速くしたいのか？」

と感じたのを覚えています。

SPDYが速さを求めると同時にHTTP2への道が開いていきました。
実際にHTTP2の仕様はSPDYの進化版と呼ばれ、SPDY4はHTTP2と同じ仕様なのでSPDY4以前をSPDYと呼ぶそうです。
※SPDYは役目を終え、すでにサポートを終了しています。

* HTTP2の対応状況

クライアント、サーバともほぼ出揃っている感じです
古参のブログサービスなどはまだHTTP1.1だったりする印象です。

* デモ

とにかく動かして速さを確認してみましょう
一番わかり易い特徴としてはHTTP2はHTTPSが前提になります。

.link https://www.httpvshttps.com/

なんかHTTPSとHTTPの比較みたいなサイトですが、HTTP2です
※低速のモバイル環境がおすすめ！

.link https://http2.redbox.ne.jp/?cid=blogredbox

こっちがわかりやすいかな？

* HTTP2の特徴

今日は以下の特徴について話していきたいと思います。

- ストリームの多重化
- 優先順位制御
- ヘッダ圧縮
- プッシュ

* Try HTTP2 in golang

* GoでのHTTP2対応

Go言語ではGo1.6から利用可能になっています。
※Go1.6以前でも別パッケージで開発はされており、
Go1.5より前であれば、そちらでも利用可能

Go1.8でサーバプッシュも実装されました。

* 動かしてみる

実際にGoでHTTP2サーバを立ててみます。

.code code/http2.go

    go run http2.go

* Ex:Goでおれおれ証明書

HTTP2用におれおれ証明書作ろうと思ってOpenSSLでコマンド打とうと思った時にWindows端末で環境作るのだるいなぁって思ったですけど、
ソース同梱のGoをダウンロードしている方なら以下を実行するだけでおれおれ証明書を作成できます。

    go run $GOROOT/src/crypto/tls/generate_cert.go -host localhost -start-date "Jan 1 15:00:00 20017" -ca

ホスト名や証明書の開始時刻を指定しています

Goって便利ですね

* 負荷をかけてみる

echo "GET https://localhost:55555" | vegeta attack -rate=1000 -duration=10s -root-certs=cert.pem | vegeta report -reporter plot > http2.html

echo "GET http://localhost:5555" | vegeta attack -rate=1000 -duration=10s | vegeta report -reporter plot > http.html


* Ex:なんとこのvegetaコマンドも。。。

え？vegetaもGoなんですか！？
Goってべんりですね！

* HTTPの特徴(紹介

* ストリームの多重化

HTTP/1.1では1リクエストで1TCP セッションを占有していました。
これにより有効帯域を使い切ることができないケースが多方面で生じていました。

HTTP/2では単一のTCP セッション内でリクエストを多重化できます。
セッションの生存期間が長くなるので
TCP のウィンドウサイズが適正値に調整され、有効帯域の利用を最大化する仕掛けを実現しています

.link https://image.slidesharecdn.com/http2fortechblog-140522235045-phpapp02/95/http2-20-638.jpg?cb=1401050889

* ヘッダ圧縮

HTTP2はヘッダを圧縮して処理を行っています
これは単純にデータ量を減らす為だけでなく、CRIME攻撃のセキュリティリスクから守る為でもあります。
詳しくは*RFC7541*をご覧ください

まぁ能書きより実際のデータがどうなっているかを見てみましょう


* HTTP1.1のヘッダ

よく見るHTTP1.1のヘッダは

    GET / HTTP1/1
    Host: www.example.com
    Accept: */*

となっています

* HTTP2のヘッダ

HTTP2では

    :method GET
    :path /
    :scheme https
    :authority www.example.com

となります。
単純にはヘッダは長くなります(:も長さに入ります

* 頻度の高いフィールドの静的テーブル化

使用頻度が高いヘッダフィールドは静的なフィールドが定義されており、
前述の例を元にすると

    :method GET = 2
    :path / = 4
    :scheme https = 7
    :authority www.example.com = 1 www.example.com

となります

.link https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-A

ここに定義してあります

* 動的なテーブル

静的テーブルのインデックスに続いて動的にテーブルを作成していきます
(現在61なので62からなので前述の

    :authority www.example.com = 1 www.example.com

が62で追加され、次のリクエストが

    :method GET = 2
    :scheme https = 7
    :authority www.example.com = 62
    :path /next.html = 4 /next.html

となります。インデックスは有限個で、FIFOで削除されていきます
同一のリクエストが来るほど、HTTP1より処理が速くなっていきます。

* 圧縮部分






* ストリームの優先順位

HTTP1.1までブラウザが描画した順に読み込みが行われていたため
Scriptタグを最後に書いたりしていましたが、
優先順位を記述することで、読み込み順を制御することができるようになりました。

これについては簡単に
実際にやってみましょう



* サーバプッシュ

HTTP2はクライアントからリクエストがなくても、レスポンスを返すことができます。。。
ちょっと何言ってるかわからないです。


* 予想されるリクエストを前もって送信

例えばindex.htmlがリクエストされる際に予想されるCSSやJS、画像ファイルがありますが、これらを一緒に送ってしまおう！っていう仕組みです

※プッシュ通知などとは違います


* 実際の仕組み

はじめのリクエスト自体は通常と変りなく行われています。

クライアントからヘッダフレームが送られるとプッシュをどのように行うかを
その後サーバはプッシュのため(データではない)のフレームを返します
この時にプッシュで使用するストリームデータのIDを指定します

レスポンスとしてデータのストリームとして本体とプッシュするデータを返します

レスポンスを受けとったクライアントはHTMLを解析して、次のリクエストを送りますが、すでにプッシュされれているので（通信中かも）そのデータを利用して、読み込むことでリクエストなしでデータを利用することができます。



* 実際のコード

.code code/push.go /START OMIT/,/END OMIT/


* デモ

実際動かしてみてみましょう

ブラウザでの確認ですがリクエストに「Push」と出ています


* HTTP2の適用へ

* 実際の現場では

単純にHTTP2は速いですが、実際の現場では問題等も起こってくると思うので注意してください。

- ネットワーク中間装置などの問題
- TCPコネクション時間が長くなる
- アプリケーションの対応


