ikascrewのgRPC
polidogと学ぶネットワーク
20 Mar 2017

Tags: polidog,golang,grpc,ikascrew

VJ イカスクリュー
http://kascrew.appspot.com/
@ikascrew

* 自己紹介

- VJ : ikascrew
- GitHub :secondarykey/ikascrew

* ikascrew is なに？

* VJをご存じですか？

クラブでDJの後ろに映像を流している人です

※デモ

* ikascrewとは

ikasccrewはVJを行う為のソフトです
ソフトやVJを始めるには初期投資が結構かかります。

これをなんとかフリーでできないかな？と始めたのがikascrewで
golangで実行されています

私にとっては大事なところなんですが、
イカスクリューが使用しているVJソフトが「ikascrew」で
VJ イカスクリューとは別の存在です。

* ikascrew 構造の説明

ikascrewにはサーバとクライアントが存在します。
サーバは映像をプロジェクタ側に流す仕組みの部分、
クライアントはプロジェクタ側に指示する部分になります。

なぜ同一プロセスになっていないかについては

- 動画周りの処理がスレッドをまたぐような処理に向いてない
- Golangに(満足のいく)GUIが存在しない

などもう少しあるのですが、それはまた別の話で

* クライアント-サーバの通信

今年はじめにかなり勢力的にイベントをこなしていたのですが、
あまりにもソフトがしょぼすぎて、一旦休養期間を設けていまして現在休養期間(リファクタリング)中です

通信部分は少し前までRESTで実現していました。
この部分をgRPCにしたらかっちょえーなーってことで採用になりました。

* gRPC

* gRPCについて

gRPCはRPCの次世代版です。

RPCはご存知の方もいらっしゃると思いますが、
Remote Procedure Callと呼ばれるリモートに存在するルーチンを実行することができる技術です。gは・・・多分Googleです。

gRPCは通信方式にHTTP2を採用していまして、今回の話をさせていただくことになりました。今回はGoの話ですが、各言語で使用することが可能になっています。

.link http://www.grpc.io/docs/

* 利用事例

- TensorFlow
- Dockerのcontainerd

あたりで使われています

* 何がいいのか？

gRPCを利用することで享受できるものはたくさんあります。

- 透過的なHTTP2の利用
- いろんな言語で扱うことができる
- タイプセーフ(型がある場合かな？)

まぁコードを書く分にはjsonの型で消耗しなくていいので大変精神衛生が保ててよかった。

* 欠点

実際の運用(いやikascrewも実運用するんですが、サービスという観点で)となると難しい部分もあるのかな？

去年のごーこん資料が運用面での部分を書かれています

.link https://speakerdeck.com/kazegusuri/go-conference-2016-spring


* Protcol Buffers

* ProtocolBuffers とは？

gRPCはProtocolBuffersというシリアライズとプロトタイプをベースにして作られています。

ProtocolBuffersはIDL(インターフェース定義言語)でGoogleにより開発されています

* コンパイラprotocのインストール

コンパイラであるprotocコマンドを各環境に合わせて持ってきます。

.link https://github.com/google/protobuf/releases

からダウンロードしてきます。
varsionは3以上を使ってください

    protoc --version

※go,C++以外の環境はビルドツールとか使っていたので、
 コマンドのインストールは必要ないかも

* プラグインの取得

protocがGoファイルを作成する為のプラグインをインストールします

    go get -u github.com/golang/protobuf/proto-gen-go

.link https://github.com/golang/protobuf

proto-gen-goが$PATHに設定されている必要があります


* プロトコルを書く

gRPCで使用するプロトコルを記述する必要があります
examplesを参考にしてみましょう

.link https://github.com/grpc/grpc-go/blob/master/examples/helloworld/helloworld/helloworld.proto

まずシンタックスをproto3と記述します

    syntax "proto3";

* サービスの作成

サービスを定義します

.code code/pb/helloworld.proto /SERVICE START/,/SERVICE END/

GreeterサービスをはSayHello()という呼び出しがあって、
HellowRequestを引数にして、HelloReplyを返します

* HelloRequestの定義

messageとして型を記述します

.code code/pb/helloworld.proto /REQUEST START/,/REQUEST END/

クライアントからnameを渡します

.code code/pb/helloworld.proto /REPLY START/,/REPLY END/

サーバはnameからmessageを作成して返します

* Ex:引数の種類

.link https://developers.google.com/protocol-buffers/docs/proto3#scalar 

この辺りに定義の仕方は記述してあります


* コンパイル

作成したファイルをコンパイルして、Goの定義を作成します

    protoc --go_out=plugins=grpc:. *.proto

同一階層に *.pb.goというファイルが作成されます

* 生成されたファイル

生成されたファイルを除くと定義した構造体や、サービス名のServer,Clientが自動生成されていることがわかります

.code code/pb/helloworld.pb.go 38,40

.code code/pb/helloworld.pb.go 55,57

.code code/pb/helloworld.pb.go 110,113

.code code/pb/helloworld.pb.go 86,89

* 実装

* 準備

実装する為には

    go get google.golang.org/grpc/

を行う必要があります

また出力されたGoファイル使う為に
pbディレクトリを作成して、そこに突っ込んでいます

実装上では

    import pb "./pb"

としています

* gRPC Server

* Listenを作成

まずはサーバを記述します

.code code/server.go /LISTEN_START/,/LISTEN_END/

TCPでLISTENを作ります

* サーバの起動

grpcパッケージからサーバを生成し、
それを登録します

.code code/server.go /SERVE_START/,/SERVE_END/

listenを利用してサーバを立ち上げます

* 処理を記述

プロトコルに書いたinterfaceを記述します

.code code/server.go /SAY_START/,/SAY_END/

通常のWeb処理のように記述しますが、
Request,Responseではなく
Request構造体で受け取り、それをReplyで返すという記述になります

* gRPC Client

* 接続するクライアントを作成

起動しているサーバへの接続を記述します

.code code/client.go /DIAL_START/,/DIAL_END/

* クライアントを生成

.code code/client.go /CLIENT_START/,/CLIENT_END/

* 呼び出してみる

.code code/client.go /SAY_START/,/SAY_END/

* 実行してみる

    go run server.go

でサーバを起動します

    go run client.go

を行います(引数に渡すとnameが変更されます

* ikascrewに適用

これを元にikascrewに適用してみました

.link https://github.com/secondarykey/ikascrew/blob/structure/pb/ikascrew.proto

Syncはクライアント起動時に行われるサーバ情報の取得

Effectはどのようなエフェクトで映像を切り替えるかです


