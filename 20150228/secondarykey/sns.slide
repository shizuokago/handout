軽量SNSを作ってみた！
Shizuoka.go
28 Feb 2015
Tags: golang shizuoka_go

secondarykey
Bartender, Programer
admin@localhost
http://github.com/secondarykey
@secondarykey

* 自己紹介

- name:secondarykey
- job:Bartender,Programer
- Twitter:secondarykey
- GitHub :secondarykey

* Shizuoka.go

今年初開催です。

2014年「静岡を席巻する」と息巻いて
始めたShizuoka.goですが、今年もやっていきます！

本日は


* 前回までのShizuoka.goは？

.link http://shizuokago.github.io/

に作っておきました。
聞きたい話があったら、みたり聞いてしてください。

* Shizuoka.go Organization

githubに作っておきました。
本日の資料、ページの管理やってます。

アプリも管理しておこうかな？

もしよければ参加を。
.link http://github.com/shizuokago/

* Go言語詳細

- 静的型付け言語
- コンパイル速度が速い
- クロスコンパイル
- GoogleAppEngineで動作
- 軽量な並行処理


* 今日はSNSを作ってみる

いつもは言語仕様を元にハンズオン形式で行ってますが、
本日は作ったものを発表形式で紹介したいと思います。

* SNSを作る理由

- 顧客のネット環境がクローズド
- メールアドレスをもらえてない
- メッセンジャーでリーダーと話すのみ
- チームの課題が見えにくい

これだと重大な決定事項のニュアンスや
チームの意識統制ができない＞＜

* 今日やること

普段はGoogleAppEngineで作ることが多いですが、
本日はオンプレミスでの作成になります。

- サーバをたてる
- ログイン処理
- データベースアクセス

辺りを行えばシステム構築ができるはず！



* 注意点

  go get

でライブラリを利用すると
比較的、簡単に開発が可能です。

ただ今回は極力使わないという意識を持って
作成しています。

オンプレミスの基本を理解したり、
Go言語がどのように動くかを理解するためです。

* Webサーバをたてる


  http.HandleFunc("/", handler)
  err = http.ListenAndServe(":5555", nil)

上記コードで簡単にWebサーバを立てられます。
*ポートはもちろん5555!!!!*

サーバが立てやすいので簡単なツールなどを
公開することができます。

* handlerについて

http.HandleFunc()に渡している第２引数は

  func handler(w http.ResponseWriter,r *http.Request) {
  }

として定義している関数を渡しています。

* URLについて

  http.HandleFunc("/login", loginHandler)
  http.HandleFunc("/logout", logoutHandler)
  http.HandleFunc("/upload", uploadHandler)

Webアプリを作成していくと
となり、増えていくと厄介になります。

ディレクトリとして

  http.HandleFunc("/", hogeHandler)

として登録しておくと、上記登録以外のアクセスがすべてきます。

* Ex:使うなら。。。

- github.com/gorilla/mux

などが楽ですね。

  r = mux.NewRoute()
  r.HandleFunc("/{key}",hogeHandler)

と指定して、keyが取得できます。
数値のみとかの設定ができたりもします。


* ファイルサーバをたてる

静的なファイルは

  http.Handle("/static/", http.FileServer(http.Dir("webroot"))

のようにすることで
アクセスが可能になります。


* テンプレートを使用する

HTMLを直接文字列で書き込むことができますが、
テンプレート機能が標準であるので
使った方が良いでしょう。

  tmpl := template.Must(template.ParseFiles(tmplName))
  tc := make(map[string]interface{})
  tc["User"] = user
  tc["Category"] = category
  tmpl.Execute(w, tc)

マップを渡してHTMLを動的に書き出します。

* HTML部分

  <li><a href="#">{{.User.Name}}</a></li> 

という感じでアクセスします。

* 段組を扱う

  template.ParseFiles()

は複数ファイルを渡すことが可能です。
例えばlayout.html,index.htmlを連結したい時は

  layout.html
  {{template "content"}}

  index.html
  {{define "content"}}
  hogehoge
  {{end}}

こんな感じです。

* アップロードする

  file, _, err := r.FormFile("uploadFile")
  out, err := os.Create(path)
  _, err = io.Copy(out, file)

この場合は、ReaderをFormFile()で作成、
Writerをファイルから作成しています。

* WebSocketを使う

会話部分にWebsocketを使用することにしました。
※そんなにさばく理由はないんですけど

- golang.org/x/net/websocket

  http.Handle("/ws/", s.WebsocketHandler())

* クライアントの処理

  var ws = new WebSocket("ws://" + location.host + "/ws/");
  //sending
  ws.send(json);
  //reciving
  ws.onmessage = function(e) { 
    // e.data; 
  }
  // onerror,onopen

* goroutineを利用する

ここで注意するのは、Handleを登録するだけだと
コネクト終わった後にサーバのプロセスが終了してします。

なのでサーバではずっと

  //永久ループ
  for {
  }

で回して、処理を待ち受けます
それだけだとダメ(処理が止まる)で
goを付け足して、待ち受けます

* チャネルを使用する

その待受処理内部で
処理をするようにチャネルを利用します。

※なんかクライアントの絵

* UUIDでクライアント管理

クライアントのIDをUUIDにすることにしました。

- github.com/satori/go.uuid

  uuid.NewV4().String()

ほら簡単に手に入る。そうgolangならね。

* ログインを行う

ユーザを認識したいので
ユーザ認証を行うようにします。

- データベースに保存
- それをセッションで管理

で認証したいと思います

* セッション管理

セッション部分も自作しようと思いましたが
ちょっと難しい感じ

- github.com/gorilla/sessions

を利用することにしました。

  store = sessions.NewCookieStore([]byte("secret"))
  session, _ := store.Get(r, config.Session.Name)                         
  user := session.Values["User"]

  session.Values["User"] = user
  err = session.Save(r, w)

* gob について

単純にいうとシリアライザです。
セッションに登録する型を登録しておく必要があります。

- encoding/gob

  gob.Register(&db.User{})

_init()などで一回登録しておくとOKです_


* データベースアクセス

データベースアクセスには標準ライブラリ

- database/sql

を使用しますが、実質のデータベースアクセスは
ドライバによってアクセスします。

* sqlite3 を選択

sqlite3を選択したので、そのドライバは

- github.com/mattn/go-sqlite3

を使用して行います。
ここに公式の一覧があります。

.link https://github.com/golang/go/wiki/SQLDrivers

* SQLを書く

database/sql.Open()でsql.Dbを生成してから 
それぞれのメソッドを使って処理します。

*DDLなどを書く*
  db.Exec(sql)

*SELECTを書く*
  db.QueryRow(sql,?).Scan(param1,2,3)

*INSERT(Tx)を書く*
  tx := db.Begin()
  stmt ,err := tx.Prepare(sql)
  stmt.Exex(param1,2,3)

* ORマッパがいいですよね

自分の中で決めかねています。
MVCなども加味してから行った方が良いと思うので
まだ考えてもいないです。


* 設定ファイル(TOML)

設定ファイルはgolangで比較的扱いやすいjsonを利用しようと
思ったんですけど、ちょっとカッコつけ?て
「TOML」を利用するようにしました。

TOMLとは

  [Database]     
  path="data/db/SpeakAll.db"

  [Web]
  port="5555"
  root="webroot"
  upload="data/store"

みたいなファイルです。


* 利用パッケージ

- github.com/BurntSushi/toml

  toml.DecodeFile("SpeakAll.ini", &config)

と行って構造にあった構造体にアクセス！

  type setting struct { 
    Database database
    Web      web
  }

  type database struct {
    Path string
  }

  type Web ...

* Ex:先頭は大文字

構造体使う時によくあるんですが、
Go言語では小文字を先頭にすると他のパッケージからは
アクセス不可なので
大文字にしておかないと動作しない可能性が高いです。

* 環境の話

- bitbucket.org/ymotongpoo/goenv

を使ってます。
これでGOPATHなどを設定できます。



* テストの話

- github.com/smartystreets/goconvey

* 構成

  go build src/*.go

ディレクトリの話とかしていいかも

* まとめ

以上でGo言語で行うオンプレミス開発の基本的なことを説明しました。


* 陸の孤島は解消したのか？ 

寂しいのはいつも一緒です。
