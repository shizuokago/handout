簡易SNSを作ってみた！
Shizuoka.go
28 Feb 2015
Tags: golang shizuoka_go

secondarykey
Bartender, Programer
admin@localhost
http://github.com/secondarykey
@secondarykey

* 自己紹介

- name:secondarykey
- job:Bartender,Programer
- Twitter:secondarykey
- GitHub :secondarykey

* Shizuoka.go

今年初開催です。

2014年「静岡を席巻する」と息巻いて始めたShizuoka.goですが、
今年もやっていきます！

本日は発表形式で

- 簡易SNSを作ってみた
- 公共バスのオープンデータ配信基板作ってみた
- LT:Goでの並列クイックソート

となっております。

* 前回までのShizuoka.goは？

.link http://shizuokago.github.io/

に作っておきました。
聞きたい話があったら、みたり聞いてしてください。

* Shizuoka.go Organization

GitHubに作っておきました。
本日の資料、ページの管理やってます。

アプリも作ったりして管理しておこうかな？と思っております。

もしよければ参加をお願いします。
.link http://github.com/shizuokago/

* Go言語詳細

- 静的型付け言語
- コンパイル速度が速い
- クロスコンパイル
- GoogleAppEngineで動作
- 軽量な並行処理

この辺りが代表的な特徴です。

* そして何より

.image gopher.png


* 今日はSNSを作ってみる

いつもは言語仕様を元にハンズオン形式で行ってますが、
本日は作ったものを発表形式で紹介したいと思います。

* SNSを作る理由

- 顧客のネット環境がクローズド
- メールアドレスをもらえてない
- メッセンジャーでリーダーと話すのみ
- チームの課題が見えにくい

これだと重大な決定事項のニュアンスや
チームの意識統制ができない＞＜

* 今日やること

普段はGoogleAppEngineで作ることが多いですが、
本日はオンプレミスでの作成になります。

- サーバをたてる
- ログイン処理
- データベースアクセス

辺りを行えばシステム構築ができるはず！

* 環境の話

- bitbucket.org/ymotongpoo/goenv

を使ってます。
これでGOPATHなどをアプリ毎に設定できます。

IDEは使わずにVimで開発しています。

* テストの話

- github.com/smartystreets/goconvey

を利用しています。
BDD風のテスティングフレームワークです。

*軽く環境を見せる*

* 注意点

フレームワークを使うことで
比較的、簡単に開発が可能です。

ただ今回は極力使わないという意識を持って作成しています。
多分それだとフレームワークの説明になってしまうので(^_^;)

オンプレミスの基本を理解したり、
Go言語がどのように動くかを理解するためで

* Webサーバをたてよう！

  http.HandleFunc("/", handler)
  err = http.ListenAndServe(":5555", nil)

上記コードで簡単にWebサーバを立てられます。
*ポートはもちろん5555!!!!*

サーバが立てやすいので簡単なツールなどを公開することができます。

* handlerについて

http.HandleFunc()に渡している第２引数は

  func handler(w http.ResponseWriter,r *http.Request) {
  }

として定義している関数を渡しています。
それぞれのURLで処理を行います。

* URLについて

  http.HandleFunc("/login", loginHandler)
  http.HandleFunc("/logout", logoutHandler)
  http.HandleFunc("/upload", uploadHandler)

Webアプリを作成していくと
となり、増えていくと厄介になります。

パスを

  http.HandleFunc("/store/", storeHandler)

として登録しておくと、
/store/***のアクセスがすべてきます。

* Ex:使うなら。。。

- github.com/gorilla/mux

などが楽ですね。

  r = mux.NewRoute()
  r.HandleFunc("/{key}",hogeHandler)

と指定して、keyが取得できます。
数値のみとかの設定ができたりもします。

* ファイルサーバをたてる

静的なファイルは

  http.Handle("/static/", http.FileServer(http.Dir("webroot"))

のようにすることで
アクセスが可能になります。
/static/***のアクセスはwebroot以下にすべてアクセスされます。

* Webの描画にはテンプレートを使用

Handlerの引数ResponseWriterに書き込むことで
返すページをを記述することができます。

テンプレート機能が標準(html/template)があります。

  tmpl := template.Must(template.ParseFiles(tmplName))
  tc := make(map[string]interface{})
  tc["User"] = user
  tc["Category"] = category
  tmpl.Execute(w, tc)

マップを渡してHTMLを動的に書き出します。

* HTML部分

  <li><a href="#">{{.User.Name}}</a></li> 

という感じで渡したマップにアクセスします。
これらを使って動的に記述していきます。

* 段組を扱う

  template.ParseFiles()

は複数ファイルを渡すことが可能です。
例えばlayout.html,index.htmlを連結したい時は

  <html>
  {{template "content"}}
  </html>

layout.html に記述して、

  {{define "content"}}
  hogehoge
  {{end}}

index.html にcontent部分を記述していきます。
これで大本のレイアウトとコンテンツ部分を分離できます。
※何段でも可能です。

* ファイルをアップロードする

ファイルを共有する為にファイルをアップロードする必要があります。

  file, _, err := r.FormFile("uploadFile")
  out, err := os.Create(path)
  _, err = io.Copy(out, file)

この場合は、ReaderをFormFile()で作成、
Writerをファイルから作成しています。

* アップしたファイルのアクセスをする

先ほどのstaticと同じ動きですが、
独自にアップロードしたファイルにアクセスするには

  http.ServeFile(w, r, file)

とファイル名を渡して上げれば可能です。


* WebSocketを使う

とにかくpushしたかったので
会話部分にWebsocketを使用することにしました。

サブパッケージである

- golang.org/x/net/websocket

を利用します。 通常のWebと同様に

  http.Handle("/ws/", 
      websocket.Handler(func(ws *websocket.Conn) {
      }
  )

と登録します。

* goroutineを利用する

ここで注意するのは、Handleを登録するだけだと
コネクト終わった後にサーバのプロセスが終了してします。

なのでサーバではずっと for { } で回して、処理を待ち受けます。
それだけだとダメ(処理が止まる)でgoを付け足して、待ち受けます

そこで

- Client : ユーザ毎に接続情報を持ち、待ち受ける
- Server : Clientの情報とチャネルの待ち受けを行う

を行います。

* Client 待ち受け

    for {
        msg := &message{}
        err := websocket.JSON.Receive(c.ws, msg)
        msgCh <- msg
    }

クライアント(JavaScript)から送られてくるメッセージを待ち受けます。
それをサーバが持ってるチャネルに送り込むわけです。

* Server 待ち受け

    for {
        select {
         case c := <-s.addCh:
            s.add(c)
         case c := <-s.removeCh:
            s.remove(c)
         case m := <-s.msgCh:
             for _, c := range s.clients {
                 client := c
                 go func() {
                     client.send(msg)
                 }()
             }
         }
    }

* クライアント(JavaScript)の処理

  var ws = new WebSocket("ws://" + location.host + "/ws/");
  //sending
  ws.send(json);
  //reciving
  ws.onmessage = function(e) { 
    // e.data; 
  }
  // onerror,onopen


* UUIDでクライアント管理

その接続のクライアントのIDをUUIDにすることにしました。
※結果的に色々な場所でUUIDを使用することになりました。

- github.com/satori/go.uuid

  uuid.NewV4().String()

様々なライブラリがgithubにあります。
go get で簡単に手に入る。そうgolangならね。

* ログインを行う

ユーザを認識したいので
ユーザ認証を行うようにします。

- データベースに保存
- それをセッションで管理

で認証したいと思います

* セッション管理

セッション部分も自作しようと思いましたが
ちょっと難しい感じ

- github.com/gorilla/sessions

を利用することにしました。

  store = sessions.NewCookieStore([]byte("secret"))
  session, _ := store.Get(r, "session-name")                         
  user := session.Values["User"]

  session.Values["User"] = user
  err = session.Save(r, w)

これで読み書きができます。
※storeは一度だけ生成します

* gob について

単純にいうとシリアライザです。
セッションに入れる構造体を登録しておく必要があります。

- encoding/gob

  gob.Register(&db.User{})

_init()などで一回登録しておくとOKです_


* データベースアクセス

データベースアクセスには標準ライブラリ

- database/sql

を使用しますが、実質のデータベースアクセスは
ドライバによってアクセスします。

* sqlite3 を選択

sqlite3を選択したので、そのドライバは

- github.com/mattn/go-sqlite3

を使用して行います。
ここに公式の一覧があります。

.link https://github.com/golang/go/wiki/SQLDrivers

有志(もしくはDBベンダ)により作成されております。

* SQLを書く

database/sql.Open()でsql.Dbを生成してから 
それぞれのメソッドを使って処理します。

*DDLなどを書く*

  db.Exec(sql)

*SELECTを書く*

  db.QueryRow(sql,?).Scan(param1,2,3)

*INSERT(Tx)を書く*

  tx := db.Begin()
  stmt ,err := tx.Prepare(sql)
  stmt.Exex(param1,2,3)

* ORマッパがいいですよね

自分の中で決めかねています。
MVCなども加味してから行った方が良いと思うので
まだ考えてもいないです。


* 設定ファイル(TOML)

設定ファイルはgolangで比較的扱いやすいjsonを利用しようと
思ったんですけど、ちょっとカッコつけ?て
「TOML」を利用するようにしました。

TOMLとは

  [Database]     
  path="data/db/SpeakAll.db"

  [Web]
  port="5555"
  root="webroot"
  upload="data/store"

みたいなファイルです。


* 利用パッケージ

- github.com/BurntSushi/toml

  toml.DecodeFile("SpeakAll.ini", &config)

と行って構造にあった構造体にアクセス！

  type setting struct { 
    Database database
    Web      web
  }

  type database struct {
    Path string
  }

  type Web ...

と設定していきます。

* まとめ

以上でGo言語で行うオンプレミス開発の基本的なことを説明しました。
・・・まだ開発中でデプロイしてません＞＜。

.link https://github.com/secondarykey/SpeakAll

もう少し記事をしっかり残せるようにしたら、
デプロイする予定です。
