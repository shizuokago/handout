簡易SNSを作ってみた！
Shizuoka.go
28 Feb 2015
Tags: golang shizuoka_go

secondarykey
Bartender, Programer
admin@localhost
http://github.com/secondarykey
@secondarykey

* 自己紹介

- name:secondarykey
- job:Bartender,Programer
- Twitter:secondarykey
- GitHub :secondarykey

* Shizuoka.go

今年初開催です。

2014年「静岡を席巻する」と息巻いて始めたShizuoka.goですが、
今年もやっていきます！

本日は発表形式で

- 簡易SNSを作ってみた
- 公共バスのオープンデータ配信基板作ってみた
- LT:Goでの並列クイックソート

となっております。

* 前回までのShizuoka.goは？

.link http://shizuokago.github.io/

に作っておきました。
聞きたい話があったら、みたり聞いてしてください。

* Shizuoka.go Organization

GitHubに作っておきました。
本日の資料、ページの管理やってます。

アプリも作ったりして管理しておこうかな？と思っております。

もしよければ参加をお願いします。
.link http://github.com/shizuokago/

* Go言語詳細

- 静的型付け言語
- コンパイル速度が速い
- クロスコンパイル
- GoogleAppEngineで動作
- 軽量な並行処理

この辺りが代表的な特徴です。

* そして何より

.image gopher.png

* 今日はSNSを作ってみる

いつもは言語仕様を元にハンズオン形式で行ってますが、
本日は作ったものを発表形式で紹介したいと思います。

都度質問受け付けますので言ってください。

* SNSを作る理由

- 顧客のネット環境がクローズド
- 契約上、メールアドレスをもらえてない
- メッセンジャーでリーダーと話すのみ
- ファイルを渡せない
- チームの課題が見えにくい

*陸の孤島！*

これだと重大な決定事項のニュアンスやチームの意識統制ができない＞＜

ので自分の端末をサーバにして作ってみることにしました。

* 今日やること

普段はGoogleAppEngineで作ることが多いですが、
本日はオンプレミスでの作成になります。

- サーバをたてる
- データベースアクセス

辺りを行えば構築ができるはず！

* 環境の話

- bitbucket.org/ymotongpoo/goenv

を使ってます。
これでGOPATHなどをアプリ毎に設定できます。

基本的にシェルを作ってくれるだけなので
"activate"を編集かけて動作するようにしています。
※Windowsでは動作するには少しコツが必要

* テストの話

- github.com/smartystreets/goconvey

を利用しています。
BDD風のテスティングフレームワークです。

*軽く環境を見てみましょう！*

* 一応CIも

Travis.CI,,,使おうと思ったんですけど、
ビルドエラー起こってます。＞＜。

ちなみにdorone.ioに変更予定です。
ちなみにdorone.ioのサービスはGo言語でできています。

* 注意点

フレームワークを使うことで比較的、簡単に開発が可能です。

ただ今回は極力使わないという意識を持って作成しています。
何使ったら楽かがわかるようになったら使おうかと。
*フレームワークの説明になってしまいますし(^_^;)*

オンプレミスで作成する基本を理解してみましょう！

* 一応どういう奴か見てみましょう！

- http://IP:5555
- admin@localhost / password

でログインできます。

* Webサーバをたてよう！

  http.HandleFunc("/", handler)
  err = http.ListenAndServe(":5555", nil)

上記コードで簡単にWebサーバを立てられます。
*ポートはもちろん5555!!!!*

こうやってサーバが立てやすいので
簡単なツールなどを作成しやすいです。

* handlerについて

http.HandleFunc()に渡している第２引数は

  func handler(w http.ResponseWriter,r *http.Request) {
  }

として定義している関数を渡しています。
第一引数のURLで処理を行います。

* URLについて

  http.HandleFunc("/login", loginHandler)
  http.HandleFunc("/logout", logoutHandler)

どんどん追加していきます。

  http.HandleFunc("/store/", storeHandler)

として登録しておくと、
/store/***のアクセスがすべてきます。

* Ex:使うなら。。。

- github.com/gorilla/mux

などが楽ですね。

  r = mux.NewRoute()
  r.HandleFunc("/{key}",hogeHandler)

と指定して、keyが取得できます。
数値のみとかの設定ができたりもします。

* ファイルサーバをたてる

静的なファイルは

  http.Handle("/static/", http.FileServer(http.Dir("webroot"))

のようにすることでアクセスが可能になります。
/static/***のアクセスはwebroot以下にすべてアクセスされます。

* Webの描画にはテンプレートを使用

Handlerの引数ResponseWriterに書き込むことで
返すページをを記述することができます。

テンプレート機能が標準(html/template)があります。

  tmpl := template.Must(template.ParseFiles(tmplName))
  tc := make(map[string]interface{})
  tc["User"] = user
  tc["Category"] = category
  tmpl.Execute(w, tc)

マップを渡してHTMLを動的に書き出します。

* HTML部分

  <li><a href="#">{{.User.Name}}</a></li> 

という感じで渡したマップにアクセスします。
これらを使って動的に記述していきます。

* 複数のテンプレートを扱う

  template.ParseFiles()

は複数ファイルを渡すことが可能です。
複数のファイルを渡すと、
片方を枠組みに使って片方をコンテンツ部分などで
わけることが可能です。

* 例えば

layout.html,index.htmlを連結したい時は

  <html>
  {{template "content"}}
  </html>

layout.html に記述して、

  {{define "content"}}
  hogehoge
  {{end}}

index.html にcontent部分を記述していきます。
※何段でも可能です。

* ファイルをアップロードする

ファイルを共有する為にファイルをアップロードする必要があります。

  file, _, err := r.FormFile("uploadFile")
  out, err := os.Create(path)
  _, err = io.Copy(out, file)

この場合は、ReaderをFormFile()で作成、
Writerをファイルから作成しています。

* アップしたファイルのアクセスをする

先ほどの静的なファイルと同じ動きですが、
独自にアップロードしたファイルにアクセスするには

  http.ServeFile(w, r, file)

とファイル名を渡して上げれば、
作成したファイルにアクセスすることが可能です。


* 会話部分にはWebSocketを使う

とにかくpushしたかったので
会話部分にWebsocketを使用することにしました。

サブパッケージである

- golang.org/x/net/websocket

を利用します。 通常のWebと同様に

  http.Handle("/ws/", 
      websocket.Handler(func(ws *websocket.Conn) {
      }
  )

と登録します。

* 注意点

こうしてHandleを登録するだけだと
コネクト終わった後に処理が終了してWebSocketが終了します。

なのでサーバでは for { } で回して、処理を待ち受けます。
それだけだとダメ(処理が止まる)でgoを付け足して、待ち受けます

そこで

- Client : ユーザ毎に接続情報を持ち、待ち受ける
- Server : Clientの管理とチャネルの待ち受けを行う

を行います。

* Client 待受

    for {
        msg := &message{}
        err := websocket.JSON.Receive(c.ws, msg)
        msgCh <- msg
    }

クライアント(JavaScript)から送られてくるメッセージを待ち受けます。
それをサーバが持ってるチャネルに送り込むわけです。

* Server 待受

    for {
        select {
        case c := <-s.addCh:
            s.add(c)
        case c := <-s.removeCh:
            s.remove(c)
        case m := <-s.msgCh:
            for _, c := range s.clients {
                client := c
                go func() {
                    client.send(msg)
                }()
             }
        }
    }
 
として、チャネルが来るのを待ち受けます。

* クライアント(JavaScript)の処理

  var ws = new WebSocket("ws://" + location.host + "/ws/");
  //sending
  ws.send(json);
  //reciving
  ws.onmessage = function(e) { 
    // e.data; 
  }
  // onerror,onopen


* UUIDでクライアント管理

その接続のクライアントのIDをUUIDにすることにしました。
※結果的に色々な場所でUUIDを使用することになりました。

- github.com/satori/go.uuid

  uuid.NewV4().String()

様々なライブラリがgithubにあります。
go get で簡単に手に入る。そうgolangならね。

* ログインを行う

ユーザを認識したいので、ユーザ認証を行うようにします。

- データベースに保存
- それをセッションで管理

で認証したいと思います

* セッション管理

セッション部分も自作しようと思いましたが
ちょっと難しい感じ

- github.com/gorilla/sessions

を利用することにしました。

  store = sessions.NewCookieStore([]byte("secret"))
  session, _ := store.Get(r, "session-name")                         
  user := session.Values["User"]

  session.Values["User"] = user
  err = session.Save(r, w)

これで読み書きができます。
※storeは一度だけ生成します

* gob について

単純にいうとシリアライザです。
セッションに入れる構造体を登録しておく必要があります。

- encoding/gob

  gob.Register(&db.User{})

_init()などで一回登録しておくとOKです_

* データベースアクセス

データベースアクセスには標準ライブラリ

- database/sql

を使用しますが、実質のデータベースアクセスは
ドライバによってアクセスします。

* sqlite3 を選択

sqlite3を選択したので、そのドライバは

- github.com/mattn/go-sqlite3

を使用して行います。
ここに公式の一覧があります。

.link https://github.com/golang/go/wiki/SQLDrivers

有志(もしくはDBベンダ)により作成されております。

* DBを起動する

  inst, err = sql.Open("sqlite3", rp)

database/sql.Open()でsql.Dbを生成してから 
それぞれのメソッドを使って処理します。

* DDLなど簡単なSQLを書く

  db.Exec(sql)

これで引数がいらないSQLを操作することができます。

* クエリを書く

  rows, err := db.Query(sql,?)
  defer db.Close()
  for rows.Next() {
  }

これでRows.Scan()してデータを取得します。

  err := db.QueryRow(sql,?).Scan(param1,2,3)

一行だとこんな感じです。

* TxでSQLを書く

  tx := db.Begin()
  stmt ,err := tx.Prepare(sql)
  stmt.Exec(param1,2,3)

こんな感じですね。

* ORマッパがいいですよね

自分の中で決めかねています。
MVCなども加味してから行った方が良いと思うので
まだ考えてもいないです。

* 設定ファイル(TOML)

設定ファイルはgolangで比較的扱いやすいjsonを利用しようと
思ったんですけど、ちょっとカッコつけて「TOML」を利用するようにしました。

TOMLとは

  [Database]     
  path="data/db/SpeakAll.db"

  [Web]
  port="5555"
  root="webroot"
  upload="data/store"

みたいなファイルです。
昔ながらのiniファイルってやつですねｗ

* 利用パッケージ

- github.com/BurntSushi/toml

  toml.DecodeFile("SpeakAll.ini", &config)

と行って構造にあった構造体にアクセス！

  type setting struct { 
    Database database
    Web      web
  }

  type database struct {
    Path string
  }

  type Web ...

と設定していきます。

* 追加(開発してない)機能として

- カテゴリ別の表示
- ログインユーザのアイコン登録
- 議事録機能

上２つが実装できたら
現場に投入できるかな？と思ってます。

* まとめ

以上でGo言語で行うオンプレミス開発の基本的なことを説明しました。
今後、フレームワークとかも使って行こうと思います。

.link https://github.com/secondarykey/SpeakAll

何か質問はありますか？

