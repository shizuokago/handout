実践で学ぶchan
Shizuoka.go
26 Aug 2017

Tags: golang,chan

secondarykey
Programer
http://github.com/secondarykey
@secondarykey

* 自己紹介

- Name:secondarykey
- Job:Programer
- Twitter:secondarykey
- GitHub :secondarykey

* Shizuoka.go

何かと忙しくしていまして、久しぶりの開催になります

懇親会は二光さんを予定しています。
静岡駅近くです

.link https://www.hotpepper.jp/strJ000025846/

席空いてるか確認しますので挙手を、


* Go言語

* 概要

- 静的型付言語
- 簡素な言語仕様
- 軽い並行処理の実現

* Goのバージョンについて

現在、Go1.9 (昨日公開！)です。

* Go 1.9 Release Party in Shizuoka

先日行われたパーティの様子です

.image images/party.jpg 360 480

.caption 大変盛り上がってます

* Go 1.9

様々なものがありますが、言語仕様として変更があったのは

    type T1 = T2

という「Type Aliases」新規に同一の構造体を作成できます
T2のinterfaceを保持したまま、新しく実装できる仕組みですね

他の追加についてはdaveさんの資料で

.link http://talks.godoc.org/github.com/davecheney/go-1.9-release-party/presentation.slide
.caption 資料


* どこで使われているか？

一番有名なのはDockerですかね？
VitessというMySQLのスケジューリングを用意にする為のツールなどにも使われています

最近は日本の企業事例もかなり出てきているように感じます


* そしてGopherくんかわいい

.image images/go1.jpg 360 480


* Go2

こうなります

.image images/go2.jpg 360 480

.caption 複雑にしないでくれっていうジョークです
ちなみに次のバージョンは1.10の予定です

* chanについて

* 実践を兼ねてみる

chanは実装を重ねてみないとわからないことが多いと思うので、実際にものを作っている時に起こる問題などを元に作ってみようと思います

Go言語の最後の秘宝とも言われるGUIを実装しながら、
chanについて話していきたいと思います

* shinyで画面を作る

実際に画面実装を行うようなことがある場合、おそらくQt上でのライブラリ群を使うのが良いと思いますが、
今回はサブパッケージ内でexprimentalである

golang.org/x/exp/shiny

で実装していきたいと思います

* まずは画面を出してみる

簡単に画面を出してみます

.code -numbers code/display.go /^func NewWindow/,/^}/
.caption code/display.go

golang.org/x/exp/shiny/driver.Main()を呼び出してウィンドウを作成します

渡している関数はfunc(screen.Screen)です

screen = golang.org/x/exp/shiny/screen

* 描画する領域を取得

create()内でウィンドウサイズを利用して
screen.Bufferを取り出しています

.code -numbers code/display.go /START BUFFER/,/END BUFFER/

このバッファーを更新すると画面の表示が行われます


* 実行

.code -numbers code/display.go /^func main/,/^}/
.caption code/display.go

これを実行してみます。
描画処理はないので表示されることはありません

fmt.Scanln()を呼び出して処理を止めています

* 描画してみます

draw()関数を作成し、Buffer内の座標に色を設定していきます

.code -numbers code/draw.go /START DRAW/,/END DRAW/
.caption code/draw.go

ここでは単純にランダムで色を設定していきます

* 呼び出します

Window作成後、永久ループを作成し、描画と再描画処理を行います

.code -numbers code/draw.go /START CALL/,/END CALL/

再描画処理ではBufferの値を設定してWindowに通知します

.code -numbers code/draw.go /START REPAINT/,/END REPAINT/

これを実行してみましょう！

* 一般的なGUIとして

GUIを作成したことがある方はわかると思いますが、この永久ループでの再描画処理は現実的ではありません。
GUIはマウスイベントなどを利用していろんなことを実行していきます。なのでこの画面の絵を書いているだけの処理で永久ループする方法は実プログラムとしてはいただけません。

* イベントドリブンを実装

ということでイベントドリブンを実装してみます。
※というよりこの方法が通常のShinyの再描画の方法です

.code -numbers code/event.go /START REPAINT/,/END REPAINT/
.caption code/event.go

Repaint()では単純にSend()でイベントのクラス(interface{})を送信します

* イベント部分

main()処理内に以下を記述します

.code -numbers code/event.go /START GOROUTINE/,/END GOROUTINE/

NextEvent()を永久ループで呼び出すことでSend()で送信されたinterface{}を取り出します

それでイベント処理を行うわけです

* goroutine

    go func() {
    }()

の記述は無名関数の呼び出しで、単純にはgoをつけて関数を呼び出します
そうすることで投げっぱなしで処理を進めます

    go something(arg)

というふうに関数を呼ぶことも可能です

* 投げっぱなし！

goroutineは戻り値を受ける仕組みがありません。
やり方は後述します。


* shinyのEvent処理

shinyのイベント処理の内部を見て少しgoroutineの処理の仕方をみてみましょう
screen.Windowで行っているように見えますが、Windowではなく、EventDequeで実装を行っています
※実際はWindow(interface)内に埋め込みとしてEventDeque(interface)が存在していて、Window自体は動作環境に合わせたGUI環境で実装クラス(windowImpl)が実装されていて、EventDequeの実装は

golang.org/x/exp/shiny/driver/internal/event/event.go

でinternalで実装(Deque)しています(別環境内でも同一実装)

* Ex:Goの勉強

Goの標準パッケージ(今回はサブパッケージですが)はソースも配布されていますので、中身を見てみると実装方法を見ることができます。

- HTTPサーバの作り方
- セッションの実装方法
- テストの書き方

コアな実装を行いたい時は標準パッケージを見て参考にして、勉強するのも良いと思います


* Deque(EventDeque実装)

構造体は以下のようになっています

    type Deque struct {
        mu    sync.Mutex
        cond  sync.Cond
        back  []interface{}
        front []interface{}
    }

Mutex,Condが重要なわけですが、一旦全体の処理を見ていきます
back,frontがイベントを貯めこむところです。
※frontは単純にSendFirst()を行うことでbackより優先度を高くしています(ちなみにfrontはFIFOでbackはLIFOです)

* Deque.Send()

    func (q *Deque) Send(event interface{}) {
        q.mu.Lock()
        defer q.mu.Unlock()
        if q.cond.L == nil {
            q.cond.L = &q.mu
        }

        q.back = append(q.back, event)
        q.cond.Signal()
    }

非同期処理の為いろいろ行っていますが、
単純な処理としてはSendで送られたeventをappend()で溜め込んでいるだけです

* Deque.NextEvent() 前処理

イベントを取り出す側のNextEvent()を見てみましょう！

        q.mu.Lock() 
        defer q.mu.Unlock()
        if q.cond.L == nil {
            q.cond.L = &q.mu
        }

Send()と同じような前処理を行っています

* Deque.NextEvent() 実処理

        for {
            if n := len(q.front); n > 0 {
                e := q.front[n-1] 
                q.front = q.front[:n-1]
                return e
            }   
            if n := len(q.back); n > 0 {
                e := q.back[0]
                q.back = q.back[1:]
                return e
            }
            q.cond.Wait() 
        }

取り出し自体は単純で、イベントが存在したらそれを返すだけです


* なぜ？

単純にスライスにSend()で追加をして、NextEvent()で取り出しているだけですが、どちらにも前処理としてMutexとCondが使われています。

* sync.Mutex

goroutineで呼び出される場合、並行処理である性質上、呼び出しの順序が確定しません。Mutexは排他処理になり、Lock()をかけると、他の箇所のLock()の処理がUnlock()されるまで、止まります。

.code -numbers code/mutex.go /^func main/,/^}/

サンプルは少し意味がありませんが、Send(),NextEvent()片方が呼び出される間に呼び出されても、片方の処理が終了するまで処理を待ち受けます

* sync.Cond

Cond.LはlockerでCondの管理対象になります。

Wait()を行うとSignal()が来るまで待ち受けます。lockerの状態変更も可能になり、再度戻って来た時はlock状態で戻ってきます

他に、Cond.Broadcast()というメソッドがあり、Wait()で貯めこんだ処理をすべて処理するようなこともできます。

* 他のsyncパッケージ

sync 内にはgoroutineを処理する際のツールが他にもたくさんあります

- WaitGroup = 複数のgoroutineを待ちます
- RWMutex - Reader,Writer用のMutex
- Once = 一度だけ実行をおこなう
- Pool = くるみ割りを行います

などがあり、goroutineを処理する時の行儀を定義することができます。

* Ex:gorutineの変数の扱い

goroutineは軽い並行処理で手軽に使えますが、スレッドセーフになるわけではありません
shinyのイベントモデルもユーザがgoroutineを複数立ち上げて実行をかけても、辻褄がとれるようにアトミックな実装しています

Go言語のメモリモデル
.link https://golang.org/ref/mem

goroutineの特性を理解せずに処理を行っていると明日動かなくなる可能性も秘めていることを覚えておいた方が良いでしょう

アトミックな処理をする上で簡単な方法として、

.link https://golang.org/pkg/sync/atomic/

を用いる手段もあります

* chan

* 並行実装モデル

"Do not communicate by sharing memory; instead, share memory by communicating"

共有するのではない、感じるのだ。(ちょーいやく

このcommunicateの部分をアトミックに行ったり、chanを使って実現していくわけです

* chanを簡単に使ってみる

と書きます。送信と受信です

.play -numbers code/chan_solid.go /^func main/,/^}/
.caption code/chan_solid.go

goroutine内で送信してメインで受信を待ちます

    ch<-
    <-ch

* ブロック

送信が行われない場合、受信は処理後にブロックされます
例えば送信をコメントアウトすると

    fatal error: all goroutines are asleep - deadlock!

と表示されます。

* ノンブロック

.play -numbers code/chan_block.go /^func main/,/^}/
.caption code/chan_block.go

defaultと書いて通常処理を行います
様々な処理を待ち受ける際に使用します(for文でぐるぐる)
defaultを書かないとブロックされます

* buffer,range,close

チャンネルに貯めこむ場合はmake()時に数値を書きます

.play -numbers code/chan_range.go /^func main/,/^}/
.caption code/chan_range.go

貯めこんだrangeで回すことが可能です(<-は必要なし)
使い終わったらclose()することが必要です

* time.Ticker

おそらく一番身近なchanはtime.Tickerになります
まずは秒毎に処理をするようにしてみます

.play -numbers code/chan_ticker.go /^func main/,/^}/
.caption code/chan_ticker.go

* 簡単な戻り値とタイムアウト

後述すると言いましたが、goroutineで戻り値みたいにやり取りをする場合は
引数にchanを渡してあげる必要があります

wocker()で値を設定してmain()側で受け取ります

.play -numbers code/chan_timeout.go /^func main/,/^}/

time.After()を利用してタイムアウト処理を行うことも可能です

* golang.org/x/sync/errorgroup

戻り値を処理する方法がサブパッケージで提供されています
Go言語を書く上で戻り値として切って話せないerrorを返す仕組みです

.code -numbers code/error.go /START GROUP/,/END GROUP/


* Group.WithContext

errgroupにはWithContextが実装されています

これは結構強力で処理途中で他の処理を行うことを拒否することができます


* おわかりいただけただろうか？

* 実践になってないことを。。。

chan の項も実践を兼ねるつもりだったんですけど、ちょっとうまくいきませんでした。
その途中までをお見せしましょう！

* 炎上を実装

砂嵐を出していてもしょうがないので、少し綺麗な絵を表示してみましょう！
少し前に話題？になった炎上を実装してみたいと思います

.link https://twitter.com/jagarikin/status/894452278463053824

コマをランダムに設定し、足しこんで平均を出していくという実装になります

実際こうなります

.caption go run code/flame_solid.go

絵が汚いですが、単純な色付けなのでこうなっています。
ここでは大切なことではないので、一旦無視します

* かくかくを直す

炎上としては少しかくかくしています。これをチューニングしてみます。

    map 作成開始 0.340607779
    map 作成終了 0.805051156
    map 設定完了 0.881130356

通常の動画は30fps辺りでなめらかに見えます
よって33msに一枚生成すると動画っぽく見えることになります

上の処理結果を見る限り

    map 完成まで 500ms
    map 設定まで  80ms

580ms かかってます
これをチューニングして行くわけです

* で、うまくいきませんでした

* 気をつけること

並行処理中にMapを使うことはできません。
元のアルゴリズムがMapに依存していたのが失敗でした

1024 * 512 の処理数ですので、そこにLockとかを入れたのが失敗でした。
※便利だろうがコストがかかることを忘れてはいけない

* そこで1.9のちからを！！！

並行処理中にも扱えるsync.Mapが実装されたので試してみます！

* 結果は

