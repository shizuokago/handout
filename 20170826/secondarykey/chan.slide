実践で学ぶchan
Shizuoka.go
26 Aug 2017

Tags: golang,chan

secondarykey
Programer
http://github.com/secondarykey
@secondarykey

* 自己紹介

- Name:secondarykey
- Job:Programer
- Twitter:secondarykey
- GitHub :secondarykey

* Shizuoka.go

何かと忙しくしていまして、久しぶりの開催になります

懇親会は二光さんを予定しています。
静岡駅近くです

.link https://www.hotpepper.jp/strJ000025846/

席空いてるか確認しますので挙手を、


* Go言語

* 概要

- 静的型付言語
- 簡素な言語仕様
- 軽い並行処理の実現

* Goのバージョンについて

現在、Go1.9 (昨日公開！)です。

* Go 1.9 Release Party in Shizuoka

先日行われたパーティの様子です

.image images/party.jpg 360 480

.caption 大変盛り上がってます

* Go 1.9

様々なものがありますが、言語仕様として変更があったのは

    type T1 = T2

という「Type Aliases」新規に同一の構造体を作成できます
T2のinterfaceを保持したまま、新しく実装できる仕組みですね

他の追加についてはdaveさんの資料で

.link http://talks.godoc.org/github.com/davecheney/go-1.9-release-party/presentation.slide
.caption 資料


* どこで使われているか？

一番有名なのはDockerですかね？
VitessというMySQLのスケジューリングを用意にする為のツールなどにも使われています

最近は日本の企業事例もかなり出てきているように感じます


* そしてGopherくんかわいい

.image images/go1.jpg 360 480


* Go2

こうなります

.image images/go2.jpg 360 480

.caption 複雑にしないでくれっていうジョークです
ちなみに次のバージョンは1.10の予定です

* このサンプルのソースについて

GitHub上においてますのでサンプル毎に動作させてみてください。


* chanについて

* 実践を兼ねてみる

chanは実装を重ねてみないとわからないことが多いと思うので、実際にものを作っている時に起こる問題などを元に作ってみようと思います

Go言語の最後の秘宝とも言われるGUIを実装しながら、
chanについて話していきたいと思います

* shinyで画面を作る

実際に画面実装を行うようなことがある場合、おそらくQt上でのライブラリ群を使うのが良いと思いますが、
今回はサブパッケージ内でexprimentalである

golang.org/x/exp/shiny

で実装していきたいと思います

* まずは画面を出してみる

簡単に画面を出してみます

.code -numbers code/display.go /^func NewWindow/,/^}/
.caption code/display.go

golang.org/x/exp/shiny/driver.Main()を呼び出してウィンドウを作成します

渡している関数はfunc(screen.Screen)です

screen = golang.org/x/exp/shiny/screen

* 描画する領域を取得

create()内でウィンドウサイズを利用して
screen.Bufferを取り出しています

.code -numbers code/display.go /START BUFFER/,/END BUFFER/

このバッファーを更新すると画面の表示が行われます


* 実行

.code -numbers code/display.go /^func main/,/^}/
.caption code/display.go

これを実行してみます。
描画処理はないので表示されることはありません

fmt.Scanln()を呼び出して処理を止めています

* 描画してみます

draw()関数を作成し、Buffer内の座標に色を設定していきます

.code -numbers code/draw.go /START DRAW/,/END DRAW/
.caption code/draw.go

ここでは単純にランダムで色を設定していきます

* 呼び出します

Window作成後、永久ループを作成し、描画と再描画処理を行います

.code -numbers code/draw.go /START CALL/,/END CALL/

再描画処理ではBufferの値を設定してWindowに通知します

.code -numbers code/draw.go /START REPAINT/,/END REPAINT/

これを実行してみましょう！

* 一般的なGUIとして

GUIを作成したことがある方はわかると思いますが、この永久ループでの再描画処理は現実的ではありません。
GUIはマウスイベントなどを利用していろんなことを実行していきます。なのでこの画面の絵を書いているだけの処理で永久ループする方法は実プログラムとしてはいただけません。

* イベントドリブンを実装

ということでイベントドリブンを実装してみます。
※というよりこの方法が通常のShinyの再描画の方法です

.code -numbers code/event.go /START REPAINT/,/END REPAINT/
.caption code/event.go

Repaint()では単純にSend()でイベントのクラス(interface{})を送信します

* イベント部分

main()処理内に以下を記述します

.code -numbers code/event.go /START GOROUTINE/,/END GOROUTINE/

NextEvent()を永久ループで呼び出すことでSend()で送信されたinterface{}を取り出します

それでイベント処理を行うわけです

* goroutine

    go func() {
    }()

の記述は無名関数の呼び出しで、単純にはgoをつけて関数を呼び出します
そうすることで投げっぱなしで処理を進めます

    go something(arg)

というふうに関数を呼ぶことも可能です

* 投げっぱなし！

goroutineは戻り値を受ける仕組みがありません。
やり方は後述します。


* shinyのEvent処理

shinyのイベント処理の内部を見て少しgoroutineの処理の仕方をみてみましょう
screen.Windowで行っているように見えますが、Windowではなく、EventDequeで実装を行っています
※実際はWindow(interface)内に埋め込みとしてEventDeque(interface)が存在していて、Window自体は動作環境に合わせたGUI環境で実装クラス(windowImpl)が実装されていて、EventDequeの実装は

golang.org/x/exp/shiny/driver/internal/event/event.go

でinternalで実装(Deque)しています(別環境内でも同一実装)

* Ex:Goの勉強

Goの標準パッケージ(今回はサブパッケージですが)はソースも配布されていますので、中身を見てみると実装方法を見ることができます。

- HTTPサーバの作り方
- セッションの実装方法
- テストの書き方

コアな実装を行いたい時は標準パッケージを見て参考にして、勉強するのも良いと思います


* Deque(EventDeque実装)

構造体は以下のようになっています

    type Deque struct {
        mu    sync.Mutex
        cond  sync.Cond
        back  []interface{}
        front []interface{}
    }

Mutex,Condが重要なわけですが、一旦全体の処理を見ていきます
back,frontがイベントを貯めこむところです。
※frontは単純にSendFirst()を行うことでbackより優先度を高くしています(ちなみにfrontはFIFOでbackはLIFOです)

* Deque.Send()

    func (q *Deque) Send(event interface{}) {
        q.mu.Lock()
        defer q.mu.Unlock()
        if q.cond.L == nil {
            q.cond.L = &q.mu
        }

        q.back = append(q.back, event)
        q.cond.Signal()
    }

非同期処理の為いろいろ行っていますが、
単純な処理としてはSendで送られたeventをappend()で溜め込んでいるだけです

* Deque.NextEvent() 前処理

イベントを取り出す側のNextEvent()を見てみましょう！

        q.mu.Lock() 
        defer q.mu.Unlock()
        if q.cond.L == nil {
            q.cond.L = &q.mu
        }

Send()と同じような前処理を行っています

* Deque.NextEvent() 実処理

        for {
            if n := len(q.front); n > 0 {
                e := q.front[n-1] 
                q.front = q.front[:n-1]
                return e
            }   
            if n := len(q.back); n > 0 {
                e := q.back[0]
                q.back = q.back[1:]
                return e
            }
            q.cond.Wait() 
        }

取り出し自体は単純で、イベントが存在したらそれを返すだけです


* なぜ？

単純にスライスにSend()で追加をして、NextEvent()で取り出しているだけですが、どちらにも前処理としてMutexとCondが使われています。

* sync.Mutex

goroutineで呼び出される場合、並行処理である性質上、呼び出しの順序が確定しません。Mutexは排他処理になり、Lock()をかけると、他の箇所のLock()の処理がUnlock()されるまで、止まります。

.code -numbers code/mutex.go /^func main/,/^}/

サンプルは少し意味がありませんが、Send(),NextEvent()片方が呼び出される間に呼び出されても、片方の処理が終了するまで処理を待ち受けます

* sync.Cond

Cond.LはlockerでCondの管理対象になります。

Wait()を行うとSignal()が来るまで待ち受けます。lockerの状態変更も可能になり、再度戻って来た時はlock状態で戻ってきます

他に、Cond.Broadcast()というメソッドがあり、Wait()で貯めこんだ処理をすべて処理するようなこともできます。

* 他のsyncパッケージ

sync 内にはgoroutineを処理する際のツールが他にもたくさんあります

- WaitGroup = 複数のgoroutineを待ちます
- RWMutex - Reader,Writer用のMutex
- Once = 一度だけ実行をおこなう
- Pool = くるみ割りを行います

などがあり、goroutineを処理する時の行儀を定義することができます。

* Ex:gorutineの変数の扱い

goroutineは軽い並行処理で手軽に使えますが、スレッドセーフになるわけではありません
shinyのイベントモデルもユーザがgoroutineを複数立ち上げて実行をかけても、辻褄がとれるようにアトミックな実装しています

Go言語のメモリモデル
.link https://golang.org/ref/mem

goroutineの特性を理解せずに処理を行っていると明日動かなくなる可能性も秘めていることを覚えておいた方が良いでしょう

アトミックな処理をする上で簡単な方法として、

.link https://golang.org/pkg/sync/atomic/

を用いる手段もあります

* chan

* 並行実装モデル

"Do not communicate by sharing memory; instead, share memory by communicating"

共有するのではない、感じるのだ。(ちょーいやく

このcommunicateの部分をアトミックに行ったり、chanを使って実現していくわけです

* chanを簡単に使ってみる

と書きます。送信と受信です

.play -numbers code/chan_solid.go /^func main/,/^}/
.caption code/chan_solid.go

goroutine内で送信してメインで受信を待ちます

    ch<-
    <-ch

* ブロック

送信が行われない場合、受信は処理後にブロックされます
例えば送信をコメントアウトすると

    fatal error: all goroutines are asleep - deadlock!

と表示されます。

* ノンブロック

.play -numbers code/chan_block.go /^func main/,/^}/
.caption code/chan_block.go

defaultと書いて通常処理を行います
様々な処理を待ち受ける際に使用します(for文でぐるぐる)
defaultを書かないとブロックされます

* buffer,range,close

チャンネルに貯めこむ場合はmake()時に数値を書きます

.play -numbers code/chan_range.go /^func main/,/^}/
.caption code/chan_range.go

貯めこんだrangeで回すことが可能です(<-は必要なし)
使い終わったらclose()することが必要です

* time.Ticker

おそらく一番身近なchanはtime.Tickerになります
まずは秒毎に処理をするようにしてみます

.play -numbers code/chan_ticker.go /^func main/,/^}/
.caption code/chan_ticker.go

* 簡単な戻り値とタイムアウト

後述すると言いましたが、goroutineで戻り値みたいにやり取りをする場合は
引数にchanを渡してあげる必要があります

wocker()で値を設定してmain()側で受け取ります

.play -numbers code/chan_timeout.go /^func main/,/^}/

time.After()を利用してタイムアウト処理を行うことも可能です

* golang.org/x/sync/errorgroup

戻り値を処理する方法がサブパッケージで提供されています
Go言語を書く上で戻り値として切って話せないerrorを返す仕組みです

.code -numbers code/error.go /START GROUP/,/END GROUP/


* Group.WithContext

errgroupにはWithContextが実装されています

これは結構強力で処理途中で他の処理を行うことを拒否することができます


* おわかりいただけただろうか？

* 実践になってないことを。。。

chan の項も実践を兼ねるつもりだったんですけど、ちょっとうまくいきませんでした。
その途中までをお見せしましょう！


* 炎上を実装

砂嵐を出していてもしょうがないので、少し綺麗な絵を表示してみましょう！
少し前に話題？になった炎上を実装してみたいと思います

.link https://twitter.com/jagarikin/status/894452278463053824

コマをランダムに設定し、足しこんで平均を出していくという実装になります

実際こうなります

.caption go run code/flame_solid.go

絵が汚いですが、単純な色付けなのでこうなっています。
ここでは大切なことではないので、一旦無視します

* かくかくを直す。。。

、、、このプログラムが速くないという前提でチューニングをするつもりでした。

    データ作成開始 0.514s
    データ作成終了 0.547s
    データ設定完了 0.571s

    データ完成まで 33ms
    データ設定まで 24ms

と30fpsまでは出ていませんが、それなりの作成速度が出ています

* とここまでが当日の流れ

当日のロジックでは500msでした。

これは私がスライスでいいところをmapを利用していた為で、
上記のスライドで出した時間はスライスを利用した速度、ソースです。

なのでここではスライスにした後の並行化のアプローチを元に行っていきたいと思います


* 並行化を行ってみる

既存のロジックは

- 色を決定する(下の段から平均を出す)コスト 後述(1
- 色を設定(生成)するコスト 後述(2
.caption ここでいうコストは処理時間

という風に分類しています。
※ちなみに最初のループで作ったと同時に色を作成しても速くなりません。

双方ある程度コストがかかるので、
この２つを並行で行うことで、速さを出したいと考えました。


* アプローチ１

* 簡単に並行化

chanを利用して色が決定すると同時に、色を設定して行くようにします

.code -numbers code/flame_chan.go /^type point/,/^}/
.caption code/flame_chan.go

メッセージ用に構造体を作成します

* chanの待受

まず(1の部分は必ずgo func()を利用して、投げっぱなしにします。
これを行わないと、(1の処理が終わる度に処理を行ってくれません

2)として受信する処理を記述します

.code code/flame_chan.go /START RANGE/,/END RANGE/
.caption ch は*point型

* ロックを行う部分

このロジックは下段が決まらないと上の段の計算ができません。
よってyの処理は待受を行わなければいけません。
待受はsync.WaitGroupを使用します

.code code/flame_chan.go /START GOROUTINE1/,/END GOROUTINE1/

xの開始でWaitGroupに1を追加しています


* 終わり側の処理

chにpointを送信し、WaitGroupに終了を通知(-1)します
yの終了処理をWaitGroupで待受、終了したら、Unlockして次の処理を行います

.code code/flame_chan.go /START GOROUTINE2/,/END GOROUTINE2/


* アプローチ１結果

.caption go run code/flame_chan.go

。。。。400msとなりました。
やはりロック処理、並行化のコストが高いようです。

一旦次のアプローチに行ってみたいと思います。


* アプローチ２

* Bufferを行う

アプローチ１ではchは単純に宣言しましたが、chanにBufferを設定してみます

.code code/flame_buffer.go /START BUFFER/,/END BUFFER/
.caption code/flame_buffer.go

* アプローチ２結果

250msです！(感動していますが、元処理より遅い、、、

1024にしたのはxの最大が1024だからです。
数を大きくするとリソースはつかいますので、逆に遅くなることもあります。

その時にあった数を設定することで、処理とリソースの最適化を行うことが可能です。

* 結論

結果的にうまくいきませんでした。

* 並行化で気をつける点

* 並行化のコスト

今回のデータ量は1024x512です。
この処理回数で並行化を行うと、１回の処理が並行化の恩恵より、並行化の弊害になる場合あります

よく参考にある「Webアクセス」を並行化するサンプルは
１回のアクセスを並行化するとロード時間の間に他のアクセスを行うという並行化にうってつけの条件と言えます。

.link https://talks.golang.org/2012/concurrency.slide#50

そちらではない実践的なものを見つけるつもりが、うまくいきませんでした。
並行化を行ったからといって速くなるわけではないということです^_^;

* 並行処理中にMapは使えない

最終的にスライスになってしまったので提示できませんでしたが、並行処理中にマップを使うことはできません。

Go1.9からsync.Mapが実装されていますのでそちらを使ってみるのもいいでしょう。


* 元のアルゴリズムを見直す

今回のように並行処理を行うこともなく、結果が出る場合もありますし、
極力アトミックな処理を行わなくていいように、並行処理にあったようなデータ構造の設計に変更するということが一番大事です

例えば速さだけ見るなら、スライスは使いまわした方がいい(Arrayにする方がよいかと)とかですかね？

* 他のやり方

処理速度等を改善するという話ではないですが、
設定部分を関数化して、ループではなく、再帰で呼び出して処理を行う方法もあります。
コード的にはすっきりして好きです。

.caption code/flame_recuesive.go

興味があるなら見てみてください。

* 最後になりましたが

なんか速いロジックありそうならご教示願えればと。

